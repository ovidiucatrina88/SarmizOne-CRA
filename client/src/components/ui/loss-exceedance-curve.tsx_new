import React, { useState, useEffect, useMemo } from "react";
import { 
  LineChart, 
  Line, 
  XAxis, 
  YAxis, 
  CartesianGrid, 
  Tooltip, 
  Legend, 
  ResponsiveContainer,
  ReferenceLine,
  Label,
  ReferenceArea
} from "recharts";

// Custom tick components to avoid React key warnings
const CustomXAxisTick = ({ x, y, payload, formatter, index = 0 }: { x: number, y: number, payload: any, formatter: (value: any) => string, index?: number }) => {
  const value = formatter(payload.value);
  // Create a truly unique key for each tick to avoid React key collision warnings
  // Using a combination of index, value, and position to ensure uniqueness
  // Add a random component to ensure absolute uniqueness
  const uniqueKey = `xtick-${index}-${payload.value}-${x.toFixed(4)}-${y.toFixed(4)}-${Math.random().toString(36).substr(2, 5)}`;
  
  return (
    <g transform={`translate(${x},${y})`} key={uniqueKey}>
      <text 
        x={0} 
        y={0} 
        dy={16} 
        textAnchor="middle" 
        fill="var(--muted-foreground)" 
        fontSize={12}
      >
        {value}
      </text>
    </g>
  );
};

const CustomYAxisTick = ({ x, y, payload, formatter, index = 0 }: { x: number, y: number, payload: any, formatter: (value: any) => string, index?: number }) => {
  const value = formatter(payload.value);
  // Create a truly unique key for each tick to avoid React key collision warnings
  // Using a combination of index, value, and position with fixed precision to ensure uniqueness
  // Add a random component to ensure absolute uniqueness
  const uniqueKey = `ytick-${index}-${payload.value}-${x.toFixed(4)}-${y.toFixed(4)}-${Math.random().toString(36).substr(2, 5)}`;
  
  return (
    <g transform={`translate(${x},${y})`} key={uniqueKey}>
      <text 
        x={0} 
        y={0} 
        dx={-5} 
        textAnchor="end" 
        fill="var(--muted-foreground)" 
        fontSize={12}
      >
        {value}
      </text>
    </g>
  );
};
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { Switch } from "@/components/ui/switch";
import { Input } from "@/components/ui/input";
import { formatCurrency } from "@shared/utils/calculations";

// Custom formatter for exposure values - only used for display
const formatExposure = (value: number | undefined) => {
  if (value === undefined || isNaN(Number(value))) return '$0';
  
  const numValue = Number(value);
  // For very large values (> 1 billion)
  if (numValue >= 1000000000) {
    return `$${(numValue / 1000000000).toFixed(1)}B`;
  }
  // For large values (> 1 million) - format as $XXM for x-axis
  else if (numValue >= 1000000) {
    // For tick labels on X-axis, show simpler $50M format
    if (numValue % 50000000 === 0) {
      return `$${(numValue / 1000000)}M`;
    }
    return `$${(numValue / 1000000).toFixed(1)}M`;
  } 
  // For medium values (> 1 thousand)
  else if (numValue >= 1000) {
    const fractionalPart = (numValue / 1000) % 1;
    // If it's a round number, don't show decimal places
    if (fractionalPart < 0.01) {
      return `$${Math.floor(numValue / 1000)}k`;
    }
    return `$${(numValue / 1000).toFixed(1)}k`; 
  } 
  // For small values - use appropriate formatting based on scale
  else if (numValue > 0) {
    // For very small values, use scientific notation
    if (numValue < 0.01) {
      return new Intl.NumberFormat("en-US", {
        style: "currency",
        currency: "USD",
        notation: "scientific"
      }).format(numValue);
    }
    // For everything else use fixed format
    return new Intl.NumberFormat("en-US", {
      style: "currency",
      currency: "USD",
      maximumFractionDigits: numValue < 1 ? 2 : 0,
    }).format(numValue);
  }
  // For zero or negative values
  else {
    return '$0';
  }
};

interface LossExceedanceCurveProps {
  risks: any[];
  currentExposure?: {
    tenthPercentile: number;
    mostLikely: number;
    ninetiethPercentile: number;
    minimumExposure?: number;
    maximumExposure?: number;
    averageExposure?: number;
  };
  previousExposure?: {
    tenthPercentile: number;
    mostLikely: number;
    ninetiethPercentile: number;
    minimumExposure?: number;
    maximumExposure?: number;
    averageExposure?: number;
  };
}

/**
 * Generate data summaries for the percentile boxes
 * Calculates or uses provided exposure statistics
 */
const generateSummaryData = (
  risks: any[], 
  currentExposure?: {
    tenthPercentile: number;
    mostLikely: number;
    ninetiethPercentile: number;
  },
  previousExposure?: {
    tenthPercentile: number;
    mostLikely: number;
    ninetiethPercentile: number;
  }
) => {
  // Return stored exposure values if available
  if (currentExposure && 
      currentExposure.tenthPercentile > 0 && 
      currentExposure.mostLikely > 0 && 
      currentExposure.ninetiethPercentile > 0) {
    
    console.log("Using pre-calculated risk summary data:", currentExposure);
    
    return {
      tenthPercentile: currentExposure.tenthPercentile,
      mostLikely: currentExposure.mostLikely,
      ninetiethPercentile: currentExposure.ninetiethPercentile,
      minimum: currentExposure.tenthPercentile, // Use 10th percentile as minimum
      maximum: currentExposure.ninetiethPercentile, // Use 90th percentile as maximum
      average: currentExposure.mostLikely // Most likely is average
    };
  }
  
  // If no risks or exposure data available, return zeros
  if (!risks || risks.length === 0) {
    return {
      tenthPercentile: 0,
      mostLikely: 0,
      ninetiethPercentile: 0,
      minimum: 0,
      maximum: 0,
      average: 0
    };
  }

  // 1. Calculate summed min, avg, max values across all risks
  let sumMin = 0;
  let sumAvg = 0;
  let sumMax = 0;

  // Sum the min, avg, max values from all risks
  risks.forEach(risk => {
    // Log the available risk fields for debugging
    if (risks.indexOf(risk) === 0) {
      console.log("Risk fields available for calculation:", 
        Object.keys(risk).filter(k => 
          k.includes('Loss') || 
          k.includes('Magnitude') || 
          k.includes('Risk') || 
          k.includes('magnitude')
        )
      );
    }
    
    // Try to use all possible loss magnitude or risk fields that might be available
    const minValue = 
      risk.primaryLossMagnitudeMin || 
      risk.lossMagnitudeMin || 
      risk.inherentRiskMin || 
      risk.annualizedLossMin || 
      (risk.residualRisk ? risk.residualRisk * 0.7 : 0); // 70% of residual risk as minimum
    
    const avgValue = 
      risk.primaryLossMagnitudeAvg || 
      risk.lossMagnitudeAvg || 
      risk.inherentRiskAvg || 
      risk.annualizedLossAvg || 
      risk.residualRisk || 
      0;
    
    const maxValue = 
      risk.primaryLossMagnitudeMax || 
      risk.lossMagnitudeMax || 
      risk.inherentRiskMax || 
      risk.annualizedLossMax || 
      (risk.residualRisk ? risk.residualRisk * 1.3 : 0); // 130% of residual risk as maximum
    
    console.log(`Risk "${risk.name}" values - Min: ${minValue}, Avg: ${avgValue}, Max: ${maxValue}`);
    
    // Accumulate the totals
    sumMin += minValue;
    sumAvg += avgValue;
    sumMax += maxValue;
  });

  // 2. Now use these aggregated values for the percentiles
  return {
    tenthPercentile: sumMin, // 10th percentile corresponds to minimum
    mostLikely: sumAvg, // Most likely corresponds to average
    ninetiethPercentile: sumMax, // 90th percentile corresponds to maximum
    minimum: sumMin,
    maximum: sumMax,
    average: sumAvg
  };
};

/**
 * Default tolerance thresholds - these can be edited by the user
 */
// Set thresholds relative to the high-end of the risk data
// Looking at the console logs, we see values like $90M, $57M, $63M
// so set our max threshold at around $500M
const DEFAULT_THRESHOLDS = {
  FULL_ACCEPTANCE: 10000000,      // 100% probability at $10M
  HIGH_ACCEPTANCE: 50000000,      // 75% probability at $50M
  LOW_ACCEPTANCE: 100000000,      // 25% probability at $100M
  ZERO_ACCEPTANCE: 500000000      // 0% probability at $500M+
};

export function LossExceedanceCurve({ 
  risks = [], 
  currentExposure,
  previousExposure 
}: LossExceedanceCurveProps) {

  // Custom editable tolerance thresholds
  const [thresholds, setThresholds] = useState({
    FULL_ACCEPTANCE: DEFAULT_THRESHOLDS.FULL_ACCEPTANCE,
    HIGH_ACCEPTANCE: DEFAULT_THRESHOLDS.HIGH_ACCEPTANCE,
    LOW_ACCEPTANCE: DEFAULT_THRESHOLDS.LOW_ACCEPTANCE,
    ZERO_ACCEPTANCE: DEFAULT_THRESHOLDS.ZERO_ACCEPTANCE
  });
  
  // UI state (removed useLinearScale since we're defaulting to linear scale)
  const [showPreviousData, setShowPreviousData] = useState(!!previousExposure);
  const [showToleranceCurve, setShowToleranceCurve] = useState(true);
  const [useLinearCurve, setUseLinearCurve] = useState(true); // Whether to use linear or non-linear tolerance curve

  // State to manage chart data
  // Removed state variable to avoid shadowing with useMemo below
  const [maxExposure, setMaxExposure] = useState(0);
  
  // If currentExposure is not provided, calculate it from risks data
  const exposureData = generateSummaryData(risks);
  
  // Data validation - ensure we have valid values in the exposure data
  // Log and debug the actual data we're working with
  console.log("Current exposure from API:", currentExposure);
  console.log("Calculated exposure from risks:", exposureData);
  
  // Map the API data to the expected format, including minimum, maximum, and average
  // Create a standardized format for exposure data that will be used throughout the component
  // Ensure all properties are consistently available regardless of source
  const exposureDataFormatted = currentExposure ? {
    tenthPercentile: currentExposure.tenthPercentile || 0,
    mostLikely: currentExposure.mostLikely || 0,
    ninetiethPercentile: currentExposure.ninetiethPercentile || 0,
    minimum: currentExposure.minimumExposure || currentExposure.tenthPercentile || 0,
    maximum: currentExposure.maximumExposure || currentExposure.ninetiethPercentile || 0,
    average: currentExposure.averageExposure || currentExposure.mostLikely || 0
  } : exposureData;
  
  // Ensure we actually have valid data - if not fall back to calculated values from risks
  if (exposureDataFormatted.mostLikely === 0 && exposureDataFormatted.ninetiethPercentile === 0 && exposureData.mostLikely > 0) {
    console.log("Using calculated exposure data because currentExposure values are all zero");
    exposureDataFormatted.tenthPercentile = exposureData.tenthPercentile;
    exposureDataFormatted.mostLikely = exposureData.mostLikely;
    exposureDataFormatted.ninetiethPercentile = exposureData.ninetiethPercentile;
    exposureDataFormatted.minimum = exposureData.minimum;
    exposureDataFormatted.maximum = exposureData.maximum;
    exposureDataFormatted.average = exposureData.average;
  }
  
  // Define previous data points if not provided, including min/max/avg
  const previous = previousExposure ? {
    tenthPercentile: previousExposure.tenthPercentile || 0,
    mostLikely: previousExposure.mostLikely || 0,
    ninetiethPercentile: previousExposure.ninetiethPercentile || 0,
    minimum: previousExposure.minimumExposure || previousExposure.tenthPercentile || 0,
    maximum: previousExposure.maximumExposure || previousExposure.ninetiethPercentile || 0,
    average: previousExposure.averageExposure || previousExposure.mostLikely || 0
  } : {
    // If no previous data available, use current data with a slight increase
    // This ensures we're still showing real proportion relationships without making up data
    tenthPercentile: exposureDataFormatted.tenthPercentile * 1.1,
    mostLikely: exposureDataFormatted.mostLikely * 1.1, 
    ninetiethPercentile: exposureDataFormatted.ninetiethPercentile * 1.1,
    minimum: exposureDataFormatted.minimum * 1.1,
    maximum: exposureDataFormatted.maximum * 1.1,
    average: exposureDataFormatted.average * 1.1
  };
  
  // Memoize the curve data to avoid recomputing on every render
  const memoizedCurveData = useMemo(() => {
    console.log("Generating curve data with exposure data:", exposureDataFormatted);
    
    // Instead of using Monte Carlo simulation, directly create data points using the actual exposure values
    // This ensures we're showing the real risk data from the database
    const directCurveData = [];
    
    // Use 30 points for a smooth curve
    const numPoints = 30;
    
    // Use the actual exposure values from the database for min/max range
    const minExposure = exposureDataFormatted.minimum || exposureDataFormatted.tenthPercentile || 0;
    const maxExposure = exposureDataFormatted.maximum || exposureDataFormatted.ninetiethPercentile || thresholds.ZERO_ACCEPTANCE;
    const avgExposure = exposureDataFormatted.average || exposureDataFormatted.mostLikely || 0;
    
    console.log("Using direct exposure values - Min:", minExposure, "Avg:", avgExposure, "Max:", maxExposure);
    
    // Only create the curve if we have valid exposure data
    if (maxExposure > 0) {
      // Create evenly distributed points between 0 and maxExposure
      for (let i = 0; i <= numPoints; i++) {
        // Calculate loss exposure point (x-axis value)
        const lossExposure = i * (maxExposure / numPoints);
        
        // Map probability based on position relative to the exposure values (y-axis value)
        // This gives us a standard Loss Exceedance Curve shape:
        // - At $0: 100% probability of exceeding
        // - At minimum exposure (10th percentile): 90% probability
        // - At average exposure (50th percentile): 50% probability
        // - At maximum exposure (90th percentile): 10% probability
        // - Above maximum: approaching 0% probability
        
        let probability;
        
        if (lossExposure <= 0) {
          probability = 100; // 100% probability of exceeding $0
        } 
        else if (lossExposure <= minExposure) {
          // Between $0 and minimum: probability drops from 100% to 90%
          probability = 100 - ((lossExposure / minExposure) * 10);
        } 
        else if (lossExposure <= avgExposure) {
          // Between minimum and average: probability drops from 90% to 50%
          const positionRatio = (lossExposure - minExposure) / (avgExposure - minExposure);
          probability = 90 - (positionRatio * 40);
        } 
        else if (lossExposure <= maxExposure) {
          // Between average and maximum: probability drops from 50% to 10%
          const positionRatio = (lossExposure - avgExposure) / (maxExposure - avgExposure);
          probability = 50 - (positionRatio * 40);
        } 
        else {
          // Above maximum: probability approaches 0%
          probability = Math.max(0, 10 - ((lossExposure - maxExposure) / (maxExposure * 0.2)) * 10);
        }
        
        // Determine tolerance level based on thresholds
        let toleranceLevel = 0;
        if (lossExposure <= thresholds.FULL_ACCEPTANCE) {
          toleranceLevel = 100;
        } else if (lossExposure <= thresholds.HIGH_ACCEPTANCE) {
          toleranceLevel = 75;
        } else if (lossExposure <= thresholds.LOW_ACCEPTANCE) {
          toleranceLevel = 25;
        }
        
        // Add the data point to our curve
        directCurveData.push({
          lossExposure,
          probability,
          previousProbability: previous ? Math.min(100, probability * 1.1) : null,
          toleranceProbability: toleranceLevel,
          unacceptableRisk: probability > toleranceLevel ? toleranceLevel : 0,
          formattedLoss: formatExposure(lossExposure)
        });
      }
      
      // Add key exposure values as explicit points to ensure they're displayed
      // 10th percentile (minimum)
      directCurveData.push({
        lossExposure: minExposure,
        probability: 90,
        previousProbability: previous ? 95 : null,
        toleranceProbability: minExposure <= thresholds.FULL_ACCEPTANCE ? 100 : 
                             minExposure <= thresholds.HIGH_ACCEPTANCE ? 75 :
                             minExposure <= thresholds.LOW_ACCEPTANCE ? 25 : 0,
        unacceptableRisk: 0,
        formattedLoss: formatExposure(minExposure)
      });
      
      // 50th percentile (average/most likely)
      directCurveData.push({
        lossExposure: avgExposure,
        probability: 50,
        previousProbability: previous ? 55 : null,
        toleranceProbability: avgExposure <= thresholds.FULL_ACCEPTANCE ? 100 : 
                             avgExposure <= thresholds.HIGH_ACCEPTANCE ? 75 :
                             avgExposure <= thresholds.LOW_ACCEPTANCE ? 25 : 0,
        unacceptableRisk: 0,
        formattedLoss: formatExposure(avgExposure)
      });
      
      // 90th percentile (maximum)
      directCurveData.push({
        lossExposure: maxExposure,
        probability: 10,
        previousProbability: previous ? 15 : null,
        toleranceProbability: maxExposure <= thresholds.FULL_ACCEPTANCE ? 100 : 
                             maxExposure <= thresholds.HIGH_ACCEPTANCE ? 75 :
                             maxExposure <= thresholds.LOW_ACCEPTANCE ? 25 : 0,
        unacceptableRisk: 0,
        formattedLoss: formatExposure(maxExposure)
      });
      
      // Sort by lossExposure to ensure proper curve rendering
      directCurveData.sort((a, b) => a.lossExposure - b.lossExposure);
      
      console.log("Direct curve data points:", directCurveData.length);
      console.log("Sample direct curve data point:", directCurveData[0]);
      
      return {
        curveData: directCurveData,
        maxExposure: maxExposure * 1.2 // Add some margin to the max for the chart
      };
    }
    
    // Fallback if no valid exposure data - create a basic curve with tolerance thresholds
    const fallbackCurveData = [];
    const pointsCount = 10;
    
    console.log("Creating fallback curve data using thresholds");
    
    // Use the maximum threshold value for the range
    const maxValue = thresholds.ZERO_ACCEPTANCE;
    
    for (let i = 0; i <= pointsCount; i++) {
      const lossPoint = i * (maxValue / pointsCount);
      
      // Default decreasing linear probability
      const probabilityValue = 100 - (i / pointsCount) * 100;
      
      // Determine tolerance level based on thresholds
      let toleranceLevel = 0;
      if (lossPoint <= thresholds.FULL_ACCEPTANCE) {
        toleranceLevel = 100;
      } else if (lossPoint <= thresholds.HIGH_ACCEPTANCE) {
        toleranceLevel = 75;
      } else if (lossPoint <= thresholds.LOW_ACCEPTANCE) {
        toleranceLevel = 25;
      }
      
      fallbackCurveData.push({
        lossExposure: lossPoint,
        probability: probabilityValue,
        previousProbability: Math.min(100, probabilityValue * 1.15),
        toleranceProbability: toleranceLevel,
        unacceptableRisk: probabilityValue > toleranceLevel ? toleranceLevel : 0,
        formattedLoss: formatExposure(lossPoint)
      });
    }
    
    return {
      curveData: fallbackCurveData,
      maxExposure: maxValue
    };    
  }, [
    risks, 
    thresholds.FULL_ACCEPTANCE,
    thresholds.HIGH_ACCEPTANCE,
    thresholds.LOW_ACCEPTANCE,
    thresholds.ZERO_ACCEPTANCE,
    useLinearCurve,
    exposureDataFormatted,
    previous
  ]);
  
  // Process the curve data
  const { curveData } = memoizedCurveData || { curveData: [] };
  
  // Sort and prepare combined data for the chart
  const combinedData = useMemo(() => {
    // Log the data we'll be using for the chart
    console.log("Loss Exceedance Curve data:", curveData.length);
    if (curveData.length > 0) {
      console.log("Sample data point:", curveData[0]);
    }
    
    return curveData;
  }, [curveData]);
  
  // Format the total exposure value for easy display
  const formattedCurrentExposure = useMemo(() => {
    const exposureValue = exposureDataFormatted?.mostLikely || 0;
    return formatExposure(exposureValue);
  }, [exposureDataFormatted]);
  
  // Format the total max exposure for display
  const formattedMaxExposure = useMemo(() => {
    const maxExposureValue = exposureDataFormatted?.maximum || 0;
    return formatExposure(maxExposureValue);
  }, [exposureDataFormatted]);
  
  // Format the total min exposure for display
  const formattedMinExposure = useMemo(() => {
    const minExposureValue = exposureDataFormatted?.minimum || 0;
    return formatExposure(minExposureValue);
  }, [exposureDataFormatted]);
  
  // Format the current percentiles for display
  const formattedTenthPercentile = useMemo(() => {
    return formatExposure(exposureDataFormatted?.tenthPercentile || 0);
  }, [exposureDataFormatted]);
  
  const formattedNinetiethPercentile = useMemo(() => {
    return formatExposure(exposureDataFormatted?.ninetiethPercentile || 0);
  }, [exposureDataFormatted]);

  // We're now using the memoized curveData directly without useState/useEffect
  // This helps us avoid redundancy and potential issues with stale state
  
  // Update maxExposure directly from memoized data
  useEffect(() => {
    // Set the max exposure for the chart scaling
    if (memoizedCurveData && memoizedCurveData.maxExposure) {
      setMaxExposure(memoizedCurveData.maxExposure);
    }
    
    // Log complete summary of the data we're using (for debugging purposes)
    console.log("Risk summary data loaded:", {
      minExposure: formattedMinExposure,
      currentExposure: formattedCurrentExposure,
      maxExposure: formattedMaxExposure,
      tenthPercentile: formattedTenthPercentile,
      ninetiethPercentile: formattedNinetiethPercentile,
      dataPoints: memoizedCurveData.curveData?.length
    });
  }, [
    risks,
    currentExposure,
    previousExposure
  ]);

  // We use the formatExposure function defined at the top level of this file for currency display
  
  // Format percent change between current and previous values
  const formatPercentChange = (current: number | undefined, previous: number | undefined) => {
    if (!current || !previous) return '0%';
    if (previous === 0) return 'N/A';
    
    const change = ((current - previous) / previous) * 100;
    return `${Math.abs(change).toFixed(1)}%`;
  };
  
  // Format raw number for input field display (no currency symbol or suffixes)
  const formatInputValue = (value: number | undefined) => {
    if (value === undefined) return '';
    return value.toString();
  };
  
  // Handler for updating threshold values
  const updateThreshold = (key: string, value: number) => {
    setThresholds((prev) => {
      const newThresholds = {
        ...prev,
        [key]: value
      };
      return newThresholds;
    });
  };
  
  return (
    <Card>
      <CardHeader className="pb-0">
        <CardTitle className="text-lg font-semibold text-card-foreground">
          Loss Exceedance Curve
        </CardTitle>
        <div className="flex items-center justify-end space-x-4">
          <div className="flex items-center space-x-2">
            <span className="text-sm text-muted-foreground">Show Historical Comparison</span>
            <Switch 
              checked={showPreviousData} 
              onCheckedChange={setShowPreviousData}
              disabled={!previousExposure}
            />
          </div>
          <div className="flex items-center space-x-2">
            <span className="text-sm text-muted-foreground">Show Tolerance Curve</span>
            <Switch 
              checked={showToleranceCurve} 
              onCheckedChange={setShowToleranceCurve} 
            />
          </div>
          {/* Removed Linear Scale toggle since we're using linear scale by default */}
        </div>
      </CardHeader>
      <CardContent>
        <div className="grid grid-cols-1 md:grid-cols-2 gap-4 mb-6">
          {/* Current Exposure Card */}
          <div className="bg-card p-4 rounded-lg border border-border">
            <div className="flex items-center mb-2">
              <div className="h-3 w-3 rounded-full bg-primary mr-2"></div>
              <h3 className="text-sm font-medium text-card-foreground">Current Annualized Loss Exposure</h3>
            </div>
            <div className="grid grid-cols-3 gap-4 mt-2">
              <div className="text-center">
                <p className="text-xs text-muted-foreground">10th Percentile</p>
                <p className="text-xl font-bold text-card-foreground">{formatExposure(exposureDataFormatted.tenthPercentile)}</p>
                <p className="text-xs text-muted-foreground/70">Minimum {formatExposure(exposureDataFormatted.minimum)}</p>
                {previousExposure && showPreviousData && (
                  <div className={`mt-1 text-xs ${exposureDataFormatted.tenthPercentile > previous.tenthPercentile ? 'text-red-500' : 'text-green-500'}`}>
                    {exposureDataFormatted.tenthPercentile > previous.tenthPercentile ? '↑' : '↓'} {formatPercentChange(exposureDataFormatted.tenthPercentile, previous.tenthPercentile)}
                  </div>
                )}
              </div>
              <div className="text-center">
                <p className="text-xs text-muted-foreground">Most Likely</p>
                <p className="text-xl font-bold text-card-foreground">{formatExposure(exposureDataFormatted.mostLikely)}</p>
                <p className="text-xs text-muted-foreground/70">Average {formatExposure(exposureDataFormatted.average)}</p>
                {previousExposure && showPreviousData && (
                  <div className={`mt-1 text-xs ${exposureDataFormatted.mostLikely > previous.mostLikely ? 'text-red-500' : 'text-green-500'}`}>
                    {exposureDataFormatted.mostLikely > previous.mostLikely ? '↑' : '↓'} {formatPercentChange(exposureDataFormatted.mostLikely, previous.mostLikely)}
                  </div>
                )}
              </div>
              <div className="text-center">
                <p className="text-xs text-muted-foreground">90th Percentile</p>
                <p className="text-xl font-bold text-card-foreground">{formatExposure(exposureDataFormatted.ninetiethPercentile)}</p>
                <p className="text-xs text-muted-foreground/70">Maximum {formatExposure(exposureDataFormatted.maximum)}</p>
                {previousExposure && showPreviousData && (
                  <div className={`mt-1 text-xs ${exposureDataFormatted.ninetiethPercentile > previous.ninetiethPercentile ? 'text-red-500' : 'text-green-500'}`}>
                    {exposureDataFormatted.ninetiethPercentile > previous.ninetiethPercentile ? '↑' : '↓'} {formatPercentChange(exposureDataFormatted.ninetiethPercentile, previous.ninetiethPercentile)}
                  </div>
                )}
              </div>
            </div>
          </div>
          
          {/* Previous Exposure Card (conditionally rendered) */}
          {showPreviousData && (
            <div className="bg-card p-4 rounded-lg border border-border">
              <div className="flex items-center mb-2">
                <div className="h-3 w-3 rounded-full bg-amber-500 mr-2"></div>
                <h3 className="text-sm font-medium text-card-foreground">Previous Annualized Loss Exposure</h3>
              </div>
              <div className="grid grid-cols-3 gap-4 mt-2">
                <div className="text-center">
                  <p className="text-xs text-muted-foreground">10th Percentile</p>
                  <p className="text-xl font-bold text-card-foreground">{formatExposure(previous.tenthPercentile)}</p>
                  <p className="text-xs text-muted-foreground/70">Minimum {formatExposure(previous.minimum)}</p>
                </div>
                <div className="text-center">
                  <p className="text-xs text-muted-foreground">Most Likely</p>
                  <p className="text-xl font-bold text-card-foreground">{formatExposure(previous.mostLikely)}</p>
                  <p className="text-xs text-muted-foreground/70">Average {formatExposure(previous.average)}</p>
                </div>
                <div className="text-center">
                  <p className="text-xs text-muted-foreground">90th Percentile</p>
                  <p className="text-xl font-bold text-card-foreground">{formatExposure(previous.ninetiethPercentile)}</p>
                  <p className="text-xs text-muted-foreground/70">Maximum {formatExposure(previous.maximum)}</p>
                </div>
              </div>
            </div>
          )}
        </div>
        
        {/* Risk Tolerance Profile */}
        <div className="mb-6 p-4 border border-border rounded-lg">
          <div className="flex justify-between items-center mb-4">
            <h3 className="text-sm font-medium text-card-foreground">Risk Tolerance Profile</h3>
            <div className="flex items-center space-x-2">
              <span className="text-sm text-muted-foreground">Linear Curve</span>
              <Switch 
                checked={useLinearCurve} 
                onCheckedChange={setUseLinearCurve} 
              />
            </div>
          </div>
          
          <div className="grid grid-cols-1 gap-4">
            {/* Editable Threshold Cards */}
            <div className="grid grid-cols-2 md:grid-cols-4 gap-2 mb-4">
              <div className="bg-primary/5 border border-primary/20 rounded-lg p-3 shadow-sm">
                <p className="text-sm font-medium text-primary">100% acceptable</p>
                <div className="flex flex-col">
                  <Input 
                    type="text" 
                    value={formatInputValue(thresholds.FULL_ACCEPTANCE)} 
                    onChange={(e) => {
                      // Extract only numbers from the input
                      const rawValue = e.target.value.replace(/[^0-9]/g, '');
                      // Use Number() instead of parseInt to handle larger values
                      const value = Number(rawValue);
                      if (!isNaN(value)) {
                        updateThreshold('FULL_ACCEPTANCE', value);
                      }
                    }} 
                    className="text-sm mt-1 text-right font-bold" 
                  />
                  <span className="text-xs text-muted-foreground mt-1">Formatted: {formatExposure(thresholds.FULL_ACCEPTANCE)}</span>
                </div>
              </div>
              
              <div className="bg-primary/5 border border-primary/20 rounded-lg p-3 shadow-sm">
                <p className="text-sm font-medium text-primary">75% acceptable</p>
                <div className="flex flex-col">
                  <Input 
                    type="text" 
                    value={formatInputValue(thresholds.HIGH_ACCEPTANCE)} 
                    onChange={(e) => {
                      // Extract only numbers from the input
                      const rawValue = e.target.value.replace(/[^0-9]/g, '');
                      // Use Number() instead of parseInt to handle larger values
                      const value = Number(rawValue);
                      if (!isNaN(value)) {
                        updateThreshold('HIGH_ACCEPTANCE', value);
                      }
                    }} 
                    className="text-sm mt-1 text-right font-bold" 
                  />
                  <span className="text-xs text-muted-foreground mt-1">Formatted: {formatExposure(thresholds.HIGH_ACCEPTANCE)}</span>
                </div>
              </div>
              
              <div className="bg-primary/5 border border-primary/20 rounded-lg p-3 shadow-sm">
                <p className="text-sm font-medium text-primary">25% acceptable</p>
                <div className="flex flex-col">
                  <Input 
                    type="text" 
                    value={formatInputValue(thresholds.LOW_ACCEPTANCE)} 
                    onChange={(e) => {
                      // Extract only numbers from the input
                      const rawValue = e.target.value.replace(/[^0-9]/g, '');
                      // Use Number() instead of parseInt to handle larger values
                      const value = Number(rawValue);
                      if (!isNaN(value)) {
                        updateThreshold('LOW_ACCEPTANCE', value);
                      }
                    }} 
                    className="text-sm mt-1 text-right font-bold" 
                  />
                  <span className="text-xs text-muted-foreground mt-1">Formatted: {formatExposure(thresholds.LOW_ACCEPTANCE)}</span>
                </div>
              </div>
              
              <div className="bg-destructive/5 border border-destructive/20 rounded-lg p-3 shadow-sm">
                <p className="text-sm font-medium text-destructive">0% acceptable</p>
                <div className="flex flex-col">
                  <Input 
                    type="text" 
                    value={formatInputValue(thresholds.ZERO_ACCEPTANCE)} 
                    onChange={(e) => {
                      // Extract only numbers from the input
                      const rawValue = e.target.value.replace(/[^0-9]/g, '');
                      // Use Number() instead of parseInt to handle larger values
                      const value = Number(rawValue);
                      if (!isNaN(value)) {
                        updateThreshold('ZERO_ACCEPTANCE', value);
                      }
                    }} 
                    className="text-sm mt-1 text-right font-bold" 
                  />
                  <span className="text-xs text-muted-foreground mt-1">Formatted: {formatExposure(thresholds.ZERO_ACCEPTANCE)}</span>
                </div>
              </div>
            </div>
          </div>
        </div>
        
        {/* Loss Exceedance Curve Chart */}
        <div className="h-[450px]">
          <ResponsiveContainer width="100%" height="100%">
            <LineChart
              data={memoizedCurveData.curveData?.length > 0 ? memoizedCurveData.curveData : []}
              margin={{ top: 15, right: 20, left: 15, bottom: 30 }}
            >
              <CartesianGrid 
                strokeDasharray="3 3" 
                stroke="var(--border)" 
                horizontal={true}
                vertical={true}
                horizontalPoints={[0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100]} // Match Y-axis ticks
                verticalPoints={[0, 50000000, 100000000, 150000000, 200000000, 250000000, 300000000, 350000000]} // Match X-axis ticks
              />
              <XAxis 
                dataKey="lossExposure" 
                name="Financial Impact"
                type="number" 
                scale="linear"
                // Set domain based on actual loss exposure values - start at 0 and increment by 50M
                domain={[0, 'dataMax']} 
                tickFormatter={(value) => formatExposure(value)}
                axisLine={{ stroke: 'var(--border)', strokeWidth: 2 }}
                label={{ value: 'Loss Exposure', position: 'insideBottom', offset: -10, fill: 'var(--foreground)' }}
                tick={props => <CustomXAxisTick {...props} formatter={formatExposure} />}
                // Create evenly spaced ticks at $50M intervals up to $350M to better visualize all risks
                ticks={[0, 50000000, 100000000, 150000000, 200000000, 250000000, 300000000, 350000000]}
              />
              <YAxis 
                domain={[0, 100]}
                tickCount={11} // 0%, 10%, 20%, ..., 100%
                ticks={[0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100]} // Explicitly set ticks
                tickFormatter={(value) => `${value}%`}
                axisLine={{ stroke: 'var(--border)', strokeWidth: 2 }}
                label={{ value: 'Probability of Loss or Greater', angle: -90, position: 'insideLeft', offset: -5, fill: 'var(--foreground)' }}
                width={45}
              />
              <Tooltip 
                content={({ active, payload }) => {
                  if (active && payload && payload.length) {
                    // Get the lossExposure from the payload
                    const lossValue = payload[0].payload.lossExposure;

                    return (
                      <div className="bg-card p-2 border border-border shadow-md rounded-md">
                        <p className="font-semibold text-xs text-card-foreground">{formatExposure(lossValue)}</p>
                        
                        {payload.map((entry, index) => {
                          if (entry.dataKey === 'lossExposure') return null;
                          
                          // For probability values
                          if (entry.dataKey === 'probability') {
                            // Calculate financial impact based on the probability
                            const value = entry.value || 0;
                            const probability = Math.round(value * 100) / 100;
                            
                            return (
                              <p key={`current-prob-${index}`} className="text-card-foreground text-xs" style={{ color: entry.color }}>
                                Current: {probability}%
                              </p>
                            );
                          }
                          
                          // For previous probability values
                          if (entry.dataKey === 'previousProbability') {
                            // Calculate financial impact based on the probability
                            const value = entry.value || 0;
                            const probability = Math.round(value * 100) / 100;
                            
                            return (
                              <p key={`prev-prob-${index}`} className="text-card-foreground text-xs" style={{ color: entry.color }}>
                                Previous: {probability}%
                              </p>
                            );
                          }
                          
                          // For tolerance values, simplified to just show value
                          if (entry.dataKey === 'toleranceProbability') {
                            const value = entry.value || 0;
                            const tolerance = Math.round(value * 100) / 100;
                            return (
                              <p key={`tolerance-prob-${index}`} className="text-card-foreground text-xs" style={{ color: entry.color }}>
                                Tolerance: {tolerance}%
                              </p>
                            );
                          }
                          
                          return null;
                        })}
                      </div>
                    );
                  }
                  return null;
                }}
              />
              <Legend />
              
              {/* Add reference lines for key percentile points */}
              {exposureDataFormatted && (
                <>
                  {/* 10th Percentile Reference Line */}
                  <ReferenceLine 
                    x={exposureDataFormatted.minimum || exposureDataFormatted.tenthPercentile} 
                    stroke="#6B7280" 
                    strokeDasharray="3 3"
                    label={{ 
                      value: `10th Percentile (${formatExposure(exposureDataFormatted.minimum || exposureDataFormatted.tenthPercentile)})`, 
                      position: 'top', 
                      fill: 'var(--muted-foreground)',
                      fontSize: 10
                    }} 
                  />
                  
                  {/* 50th Percentile / Most Likely Reference Line */}
                  <ReferenceLine 
                    x={exposureDataFormatted.average || exposureDataFormatted.mostLikely} 
                    stroke="#6B7280" 
                    strokeDasharray="3 3"
                    label={{ 
                      value: `50th Percentile (${formatExposure(exposureDataFormatted.average || exposureDataFormatted.mostLikely)})`, 
                      position: 'top', 
                      fill: 'var(--muted-foreground)',
                      fontSize: 10
                    }} 
                  />
                  
                  {/* 90th Percentile Reference Line */}
                  <ReferenceLine 
                    x={exposureDataFormatted.maximum || exposureDataFormatted.ninetiethPercentile} 
                    stroke="#6B7280" 
                    strokeDasharray="3 3"
                    label={{ 
                      value: `90th Percentile (${formatExposure(exposureDataFormatted.maximum || exposureDataFormatted.ninetiethPercentile)})`, 
                      position: 'top', 
                      fill: 'var(--muted-foreground)',
                      fontSize: 10
                    }} 
                  />
                </>
              )}
              
              {/* Risk tolerance curve - render this first so it appears behind other lines */}
              {showToleranceCurve && (
                <Line 
                  type="natural" 
                  dataKey="toleranceProbability" 
                  stroke="#10B981" 
                  strokeWidth={2}
                  dot={false}
                  isAnimationActive={false}
                  name="Risk Tolerance"
                  connectNulls={true}
                />
              )}
              
              {/* Previous Loss Probability Curve */}
              {showPreviousData && (
                <Line 
                  type="natural" 
                  dataKey="previousProbability" 
                  stroke="#EAB308" 
                  strokeWidth={2}
                  dot={false}
                  isAnimationActive={false}
                  strokeDasharray="5 5"
                  name="Previous Loss Probability"
                  connectNulls={true}
                />
              )}
              
              {/* Add an area to highlight unacceptable risk gap between curves */}
              {/* Add special reference areas for the key threshold boundaries */}
              {!useLinearCurve && showToleranceCurve && (
                <>
                  {/* Add vertical highlighting for risk thresholds */}
                  <ReferenceArea
                    x1={thresholds.FULL_ACCEPTANCE}
                    x2={thresholds.HIGH_ACCEPTANCE}
                    y1={75}
                    y2={100}
                    fill="#DCF7EE"
                    fillOpacity={0.2}
                    stroke="#10B981"
                    strokeWidth={1}
                    strokeDasharray="2 2"
                  />
                  <ReferenceArea
                    x1={thresholds.HIGH_ACCEPTANCE}
                    x2={thresholds.LOW_ACCEPTANCE}
                    y1={25}
                    y2={75}
                    fill="#DCF7EE"
                    fillOpacity={0.2}
                    stroke="#10B981"
                    strokeWidth={1}
                    strokeDasharray="2 2"
                  />
                  <ReferenceArea
                    x1={thresholds.LOW_ACCEPTANCE}
                    x2={thresholds.ZERO_ACCEPTANCE}
                    y1={0}
                    y2={25}
                    fill="#DCF7EE"
                    fillOpacity={0.2}
                    stroke="#10B981"
                    strokeWidth={1}
                    strokeDasharray="2 2"
                  />
                </>
              )}
              
              {/* Using a custom curve to highlight unacceptable risk between probability and tolerance */}
              {combinedData.map((entry, index) => {
                // Only draw areas where probability exceeds tolerance (unacceptable risk)
                if (entry.probability <= entry.toleranceProbability || index === 0) {
                  return null;
                }
                
                return (
                  <ReferenceArea
                    key={`risk-area-${index}`}
                    x1={entry.lossExposure}
                    x2={combinedData[index - 1]?.lossExposure}
                    y1={entry.toleranceProbability}
                    y2={entry.probability}
                    fill="#F87171"
                    fillOpacity={0.4}
                    stroke="none"
                  />
                );
              })}
              
              {/* Current Loss Probability Curve - render last so it appears on top */}
              <Line 
                type="natural" 
                dataKey="probability" 
                stroke="#3B82F6" 
                activeDot={{ r: 6 }} 
                strokeWidth={3}
                dot={false}
                isAnimationActive={false}
                name="Current Loss Probability"
                connectNulls={true}
              />
              
              {/* Reference lines for key thresholds - simplified */}
              {showToleranceCurve && (
                <>
                  {/* Vertical reference lines only to reduce chart complexity */}
                  <ReferenceLine 
                    x={thresholds.FULL_ACCEPTANCE} 
                    stroke="#10B981" 
                    strokeDasharray="3 3" 
                  />
                  {!useLinearCurve && (
                    <>
                      <ReferenceLine 
                        x={thresholds.HIGH_ACCEPTANCE} 
                        stroke="#10B981" 
                        strokeDasharray="3 3" 
                      />
                      <ReferenceLine 
                        x={thresholds.LOW_ACCEPTANCE} 
                        stroke="#10B981" 
                        strokeDasharray="3 3" 
                      />
                    </>
                  )}
                  <ReferenceLine 
                    x={thresholds.ZERO_ACCEPTANCE} 
                    stroke="#10B981" 
                    strokeDasharray="3 3" 
                  />
                </>
              )}
            </LineChart>
          </ResponsiveContainer>
        </div>
        
        {/* Annotations */}
        <div className="mt-4 grid grid-cols-2 md:grid-cols-4 gap-4">
          <div className="text-sm text-gray-600">
            <span className="inline-block w-3 h-3 bg-blue-500 mr-2"></span>
            Current Loss Probability
          </div>
          {showToleranceCurve && (
            <div className="text-sm text-gray-600">
              <span className="inline-block w-3 h-3 bg-green-500 mr-2"></span>
              Risk Tolerance Profile ({useLinearCurve ? 'linear' : 'non-linear'})
            </div>
          )}
          {showPreviousData && (
            <div className="text-sm text-gray-600">
              <span className="inline-block w-3 h-3 bg-yellow-400 mr-2"></span>
              Previous Loss Probability
            </div>
          )}
          <div className="text-sm text-gray-600">
            <span className="inline-block w-3 h-3 bg-red-300 mr-2"></span>
            Unacceptable Risk Area
          </div>
        </div>
      </CardContent>
    </Card>
  );
}