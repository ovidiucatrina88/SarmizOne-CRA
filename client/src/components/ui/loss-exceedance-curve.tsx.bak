import React, { useState, useEffect, useMemo } from "react";
import { 
  LineChart, 
  Line, 
  XAxis, 
  YAxis, 
  CartesianGrid, 
  Tooltip, 
  Legend, 
  ResponsiveContainer,
  ReferenceLine,
  Label,
  ReferenceArea
} from "recharts";

// Custom tick components to avoid React key warnings
const CustomXAxisTick = ({ x, y, payload, formatter, index = 0 }: { x: number, y: number, payload: any, formatter: (value: any) => string, index?: number }) => {
  const value = formatter(payload.value);
  // Create a truly unique key for each tick to avoid React key collision warnings
  // Using a combination of index, value, and position to ensure uniqueness
  // Add a random component to ensure absolute uniqueness
  const uniqueKey = `xtick-${index}-${payload.value}-${x.toFixed(4)}-${y.toFixed(4)}-${Math.random().toString(36).substr(2, 5)}`;
  
  return (
    <g transform={`translate(${x},${y})`} key={uniqueKey}>
      <text 
        x={0} 
        y={0} 
        dy={16} 
        textAnchor="middle" 
        fill="var(--muted-foreground)" 
        fontSize={12}
      >
        {value}
      </text>
    </g>
  );
};

const CustomYAxisTick = ({ x, y, payload, formatter, index = 0 }: { x: number, y: number, payload: any, formatter: (value: any) => string, index?: number }) => {
  const value = formatter(payload.value);
  // Create a truly unique key for each tick to avoid React key collision warnings
  // Using a combination of index, value, and position with fixed precision to ensure uniqueness
  // Add a random component to ensure absolute uniqueness
  const uniqueKey = `ytick-${index}-${payload.value}-${x.toFixed(4)}-${y.toFixed(4)}-${Math.random().toString(36).substr(2, 5)}`;
  
  return (
    <g transform={`translate(${x},${y})`} key={uniqueKey}>
      <text 
        x={0} 
        y={0} 
        dx={-5} 
        textAnchor="end" 
        fill="var(--muted-foreground)" 
        fontSize={12}
      >
        {value}
      </text>
    </g>
  );
};
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { Switch } from "@/components/ui/switch";
import { Input } from "@/components/ui/input";
import { formatCurrency } from "@shared/utils/calculations";

// Custom formatter for exposure values - only used for display
const formatExposure = (value: number | undefined) => {
  if (value === undefined || isNaN(Number(value))) return '$0';
  
  const numValue = Number(value);
  // For very large values (> 1 billion)
  if (numValue >= 1000000000) {
    return `$${(numValue / 1000000000).toFixed(1)}B`;
  }
  // For large values (> 1 million) - format as $XXM for x-axis
  else if (numValue >= 1000000) {
    // For tick labels on X-axis, show simpler $50M format
    if (numValue % 50000000 === 0) {
      return `$${(numValue / 1000000)}M`;
    }
    return `$${(numValue / 1000000).toFixed(1)}M`;
  } 
  // For medium values (> 1 thousand)
  else if (numValue >= 1000) {
    const fractionalPart = (numValue / 1000) % 1;
    // If it's a round number, don't show decimal places
    if (fractionalPart < 0.01) {
      return `$${Math.floor(numValue / 1000)}k`;
    }
    return `$${(numValue / 1000).toFixed(1)}k`; 
  } 
  // For small values - use appropriate formatting based on scale
  else if (numValue > 0) {
    // For very small values, use scientific notation
    if (numValue < 0.01) {
      return new Intl.NumberFormat("en-US", {
        style: "currency",
        currency: "USD",
        notation: "scientific"
      }).format(numValue);
    }
    // For everything else use fixed format
    return new Intl.NumberFormat("en-US", {
      style: "currency",
      currency: "USD",
      maximumFractionDigits: numValue < 1 ? 2 : 0,
    }).format(numValue);
  }
  // For zero or negative values
  else {
    return '$0';
  }
};

interface LossExceedanceCurveProps {
  risks: any[];
  currentExposure?: {
    tenthPercentile: number;
    mostLikely: number;
    ninetiethPercentile: number;
    minimumExposure?: number;
    maximumExposure?: number;
    averageExposure?: number;
  };
  previousExposure?: {
    tenthPercentile: number;
    mostLikely: number;
    ninetiethPercentile: number;
    minimumExposure?: number;
    maximumExposure?: number;
    averageExposure?: number;
  };
}

/**
 * Generate Loss Exceedance Curve data according to FAIR-U methodology
 * LEC(x) = P(Loss > x) where x is a loss threshold
 * The curve shows the probability that a simulated loss will exceed threshold x
 */
const generateLossExceedanceCurve = (
  risks: any[], 
  toleranceThresholds: {
    FULL_ACCEPTANCE: number;
    HIGH_ACCEPTANCE: number;
    LOW_ACCEPTANCE: number;
    ZERO_ACCEPTANCE: number;
  },
  useLinearCurve: boolean,
  currentExposure?: {
    tenthPercentile: number;
    mostLikely: number;
    ninetiethPercentile: number;
    minimum?: number;
    maximum?: number;
    average?: number;
    minimumExposure?: number;
    maximumExposure?: number;
    averageExposure?: number;
  },
  // Additional parameter for directly passing exposureData if needed
  additionalExposureData?: {
    tenthPercentile: number;
    mostLikely: number;
    ninetiethPercentile: number;
    minimum?: number;
    maximum?: number;
    average?: number;
  }
) => {
  // Local exposure for calculations if provided
  const exposureData = currentExposure || generateSummaryData(risks);
  
  // Set up the scale based on tolerance thresholds
  const maxThreshold = toleranceThresholds.ZERO_ACCEPTANCE * 1.2;
  
  // Generate Monte Carlo simulation data
  const simulationCount = 10000; // Run 10,000 simulations for smooth curve
  const simulatedLosses: number[] = [];
  
  // If we have actual risk data, use it to generate simulations
  if (risks && risks.length > 0) {
    risks.forEach(risk => {
      // For each risk, generate a set of samples
      const annualLoss = risk.residualRisk || 0;
      if (annualLoss > 0) {
        // Create a normal distribution around the annual loss 
        // with standard deviation of 30% of the mean
        const mean = annualLoss;
        const stdDev = mean * 0.3;
        
        // Generate samples for this risk
        const samplesPerRisk = Math.max(100, Math.floor(simulationCount / risks.length));
        for (let i = 0; i < samplesPerRisk; i++) {
          // Box-Muller transform to generate normally distributed random values
          const u1 = Math.random();
          const u2 = Math.random();
          const z0 = Math.sqrt(-2.0 * Math.log(u1)) * Math.cos(2.0 * Math.PI * u2);
          
          // Apply standard deviation and mean
          let sample = z0 * stdDev + mean;
          // Ensure non-negative values
          sample = Math.max(0, sample);
          simulatedLosses.push(sample);
        }
      }
    });
  } 
  
  // If we don't have risk data or all risks have zero loss, generate realistic data
  if (simulatedLosses.length === 0) {
    // Check if risks array has any elements even if they don't have residualRisk values
    if (risks && risks.length > 0) {
      // Calculate summed min, avg, max values across all risks
      let sumMin = 0;
      let sumAvg = 0;
      let sumMax = 0;
      
      // Sum the min, avg, max values from all risks
      risks.forEach(risk => {
        // Try to use all possible loss magnitude or risk fields that might be available
        const minValue = 
          risk.primaryLossMagnitudeMin || 
          risk.lossMagnitudeMin || 
          risk.inherentRiskMin || 
          risk.annualizedLossMin || 
          (risk.residualRisk ? risk.residualRisk * 0.7 : 0); // 70% of residual risk as minimum

        const avgValue = 
          risk.primaryLossMagnitudeAvg || 
          risk.lossMagnitudeAvg || 
          risk.inherentRiskAvg || 
          risk.annualizedLossAvg || 
          risk.residualRisk || 
          0;
        
        const maxValue = 
          risk.primaryLossMagnitudeMax || 
          risk.lossMagnitudeMax || 
          risk.inherentRiskMax || 
          risk.annualizedLossMax || 
          (risk.residualRisk ? risk.residualRisk * 1.3 : 0); // 130% of residual risk as maximum
        
        // Accumulate the totals
        sumMin += minValue;
        sumAvg += avgValue;
        sumMax += maxValue;
      });
      
      // Log the summed values for debugging
      console.log(`Total summed risk values - Min: ${sumMin}, Avg: ${sumAvg}, Max: ${sumMax}`);
      
      // Generate samples using triangular distribution with the summed values
      const mean = sumAvg > 0 ? sumAvg : (sumMin + sumMax) / 2;
      const min = sumMin > 0 ? sumMin : mean * 0.7;
      const max = sumMax > 0 ? sumMax : mean * 1.3;
      
      if (mean > 0) {
        const stdDev = mean * 0.3;
        
        // Generate a reasonable number of samples
        for (let i = 0; i < simulationCount; i++) {
          // Box-Muller transform for normal distribution 
          const u1 = Math.random();
          const u2 = Math.random();
          const z0 = Math.sqrt(-2.0 * Math.log(u1)) * Math.cos(2.0 * Math.PI * u2);
          
          // Apply standard deviation and mean
          let sample = z0 * stdDev + mean;
          
          // Ensure sample is within min-max range
          sample = Math.max(min, Math.min(max, sample));
          simulatedLosses.push(sample);
        }
      }
    }
    
    // If we still don't have simulated losses, create some based on thresholds
    if (simulatedLosses.length === 0) {
      // Generate data in three segments to create a more realistic curve
      
      // 1. Lower range - 50% of points
      const lowerMean = toleranceThresholds.FULL_ACCEPTANCE * 1.5;
      const lowerStdDev = lowerMean * 0.6;
      
      // 2. Mid range - 30% of points
      const midMean = toleranceThresholds.HIGH_ACCEPTANCE * 0.8;
      const midStdDev = midMean * 0.4;
      
      // 3. High range - 20% of points (rare high-impact events)
      const highMean = toleranceThresholds.LOW_ACCEPTANCE * 0.9;
      const highStdDev = highMean * 0.5;
      
      // Generate the three segments
      for (let i = 0; i < simulationCount * 0.5; i++) {
        const u1 = Math.random();
        const u2 = Math.random();
        const z0 = Math.sqrt(-2.0 * Math.log(u1)) * Math.cos(2.0 * Math.PI * u2);
        
        let sample = z0 * lowerStdDev + lowerMean;
        sample = Math.max(0, sample);
        simulatedLosses.push(sample);
      }
      
      for (let i = 0; i < simulationCount * 0.3; i++) {
        const u1 = Math.random();
        const u2 = Math.random();
        const z0 = Math.sqrt(-2.0 * Math.log(u1)) * Math.cos(2.0 * Math.PI * u2);
        
        let sample = z0 * midStdDev + midMean;
        sample = Math.max(0, sample);
        simulatedLosses.push(sample);
      }
      
      for (let i = 0; i < simulationCount * 0.2; i++) {
        const u1 = Math.random();
        const u2 = Math.random();
        const z0 = Math.sqrt(-2.0 * Math.log(u1)) * Math.cos(2.0 * Math.PI * u2);
        
        let sample = z0 * highStdDev + highMean;
        sample = Math.max(0, sample);
        simulatedLosses.push(sample);
      }
    }
  }
  
  // If no simulated losses, we'll show an empty chart
  // but ensure we don't cause runtime errors with empty arrays
  
  // Sort simulated losses in descending order
  simulatedLosses.sort((a, b) => b - a);
  
  // Generate reverse-ordered loss threshold points (highest to lowest)
  // Use fewer points to improve rendering performance
  const numPoints = 30; // Reduced from 50 to 30 points to have fewer overlaps
  
  // Handle empty array case to prevent Math.max errors
  let maxLoss = maxThreshold || 1000000; // Default to $1M if no data
  if (simulatedLosses.length > 0) {
    maxLoss = Math.max(...simulatedLosses, maxThreshold || 0);
  }
  const points = [];
  
  // Track previous values to avoid duplicates
  let prevProbability = -1;
  let smallOffset = 0.001;
  
  // Determine the minimum exposure value
  // For real data, don't enforce any minimums
  // If we have exposureData, use actual minimum value for better accuracy
  const minExposure = exposureData?.minimum ? 
    exposureData.minimum : 
    Math.max(0, Math.round(maxLoss / 1000));
  
  // Use logarithmic scale for X-axis values
  const useLog = true; // Use logarithmic scale for better visualization
  
  // Generate data points from highest (maxLoss) to lowest (minExposure)
  // This matches the FAIR Loss Exceedance Curve presentation
  for (let i = 0; i <= numPoints; i++) {
    // Calculate the position between maxLoss and minExposure where
    // i=0 → maxLoss and i=numPoints → minExposure
    let lossExposure;
    
    if (useLog) {
      // Logarithmic distribution (more points at higher values)
      const logMin = Math.log10(minExposure);
      const logMax = Math.log10(maxLoss);
      // Reverse the position calculation to start from highest value
      const logValue = logMax - (i / numPoints) * (logMax - logMin);
      lossExposure = Math.pow(10, logValue);
    } else {
      // Linear distribution from maxLoss to minExposure
      // Reversed to start from the highest value
      lossExposure = maxLoss - (i / numPoints) * (maxLoss - minExposure);
    }
    
    // Round to nearest whole number but don't enforce a minimum
    lossExposure = Math.round(lossExposure);
    
    // Calculate exceedance probability: P(Loss > lossExposure)
    // Make sure we have some simulated losses before calculating probability
    const exceedCount = simulatedLosses.filter(loss => loss > lossExposure).length;
    
    // If there are no simulated losses exceeding the threshold, create a curve
    // based on actual exposure data or a smooth inverse curve
    let probability;
    
    if (simulatedLosses.length === 0) {
      // If we have exposure data, use a more realistic curve based on the actual exposure values
      // Prefer the current formatted exposure data which now has fallbacks to calculated values
      const dataToUse = exposureDataFormatted;
      
      // Log the data being used for probability calculation
      console.log("Data being used for probability calculation:", dataToUse);
      
      if (dataToUse && (dataToUse.mostLikely > 0 || dataToUse.ninetiethPercentile > 0)) {
        // Higher exposure should have lower probability
        // 90th percentile (maximum) should be at 10% probability
        // 10th percentile (minimum) should be at 90% probability
        // Interpolate in between
        
        // Normalize lossExposure between minimum and maximum from exposure data
        const minExp = Math.max(0, dataToUse.minimum || dataToUse.tenthPercentile || 0);
        const maxExp = Math.max(minExp + 1, dataToUse.maximum || dataToUse.ninetiethPercentile || 1);
        
        // Calculate position from 0.0 to 1.0 in the range, inverted for probability calculation
        const normalizedPosition = 1 - Math.min(1, Math.max(0, 
          (lossExposure - minExp) / (maxExp - minExp)
        ));
        
        console.log(`Loss exposure: ${lossExposure}, MinExp: ${minExp}, MaxExp: ${maxExp}, Position: ${normalizedPosition}`);
        
        // Map to probability range: 0.0 -> 10%, 1.0 -> 90%
        probability = 10 + (normalizedPosition * 80);
      } else {
        // Fallback to basic inverse relationship if no exposureData
        const maxLossScale = maxLoss || thresholds.ZERO_ACCEPTANCE;
        probability = Math.max(0, 100 - (lossExposure / maxLossScale) * 100);
      }
    } else {
      probability = (exceedCount / simulatedLosses.length) * 100;
    }
    
    // Ensure unique probability values to avoid key conflicts
    if (Math.abs(probability - prevProbability) < 0.0001) {
      // Add a tiny increasing offset to ensure unique values
      probability += smallOffset;
      smallOffset += 0.001; // Increase for next potential duplicate
    } else {
      smallOffset = 0.001; // Reset the offset
    }
    prevProbability = probability;
    
    // Calculate tolerance probability based on thresholds
    let toleranceProbability = 0;
    
    // Always use simple linear tolerance curve for clarity and to avoid key issues
    // Tolerance curve shows the maximum probability we're willing to accept
    // at each financial impact level
    if (lossExposure <= toleranceThresholds.FULL_ACCEPTANCE) {
      // Below FULL_ACCEPTANCE threshold: we accept 100% probability of this level of loss
      toleranceProbability = 100;
    } else if (lossExposure >= toleranceThresholds.ZERO_ACCEPTANCE) {
      // Above ZERO_ACCEPTANCE threshold: we accept 0% probability of this level of loss  
      toleranceProbability = 0;
    } else {
      // In between: linear interpolation from 100% to 0%
      const range = toleranceThresholds.ZERO_ACCEPTANCE - toleranceThresholds.FULL_ACCEPTANCE;
      // Calculate how far between FULL and ZERO we are (0.0 to 1.0)
      const progress = (lossExposure - toleranceThresholds.FULL_ACCEPTANCE) / range;
      // Interpolate from 100% at FULL to 0% at ZERO
      toleranceProbability = 100 - (progress * 100);
    }
    
    // Calculate unacceptable risk area
    // If the current probability is greater than tolerance, this is an unacceptable risk area
    let unacceptableRisk = 0;
    
    if (probability > toleranceProbability) {
      // Create a shaded area between the current probability and the tolerance line
      // This represents the gap between what we have and what's acceptable
      unacceptableRisk = toleranceProbability;
    }
    
    // Ensure lossExposure is a valid number, not null or undefined
    const validLossExposure = Number.isFinite(lossExposure) ? lossExposure : 0;
    
    // Use the actual financial values from the current exposure data
    // to ensure we're showing the right values at key percentiles
    let lossValue = validLossExposure;
    
    // Map key probability points to actual financial values from exposure data
    // This helps ensure the chart shows realistic values at key points
    // Prefer currentExposure over exposureData as it's already properly mapped
    if (currentExposure) {
      // For points at specific probability levels, use the actual financial values
      if (Math.abs(probability - 10) < 5) {
        lossValue = currentExposure.minimum || currentExposure.tenthPercentile;
      } else if (Math.abs(probability - 50) < 5) {
        lossValue = currentExposure.average || currentExposure.mostLikely;
      } else if (Math.abs(probability - 90) < 5) {
        lossValue = currentExposure.maximum || currentExposure.ninetiethPercentile;
      }
    } else if (additionalExposureData) {
      // Next try additionalExposureData if available
      if (Math.abs(probability - 10) < 5) {
        lossValue = additionalExposureData.minimum || additionalExposureData.tenthPercentile;
      } else if (Math.abs(probability - 50) < 5) {
        lossValue = additionalExposureData.average || additionalExposureData.mostLikely;
      } else if (Math.abs(probability - 90) < 5) {
        lossValue = additionalExposureData.maximum || additionalExposureData.ninetiethPercentile;
      }
    } else if (exposureData) {
      // Fallback to exposureData if neither of the above are available
      if (Math.abs(probability - 10) < 5) {
        lossValue = exposureData.minimum || exposureData.tenthPercentile;
      } else if (Math.abs(probability - 50) < 5) {
        lossValue = exposureData.average || exposureData.mostLikely;
      } else if (Math.abs(probability - 90) < 5) {
        lossValue = exposureData.maximum || exposureData.ninetiethPercentile;
      }
    }
    
    const dataPoint = {
      // Add unique ID to ensure React has unique keys
      id: `point-${i}-${lossExposure.toFixed(3)}-${probability.toFixed(5)}`,
      // Use the determined loss exposure value
      lossExposure: lossValue,
      probability: Number.isFinite(probability) ? probability : 0,
      // Create a comparison curve using previous data or 1.2x current
      previousProbability: Number.isFinite(probability) ? Math.min(100, probability * 1.2) : 0,
      toleranceProbability: Number.isFinite(toleranceProbability) ? toleranceProbability : 0,
      unacceptableRisk: Number.isFinite(unacceptableRisk) ? unacceptableRisk : 0,
      // Store formatted value for display with correct currency formatting
      formattedLoss: formatExposure(lossValue)
    };
    
    points.push(dataPoint);
  }
  
  return points;
};

// Generate data summaries for the percentile boxes
const generateSummaryData = (
  risks: any[], 
  currentExposure?: {
    tenthPercentile: number;
    mostLikely: number;
    ninetiethPercentile: number;
  },
  previousExposure?: {
    tenthPercentile: number;
    mostLikely: number;
    ninetiethPercentile: number;
  }
) => {
  // Return stored exposure values if available
  if (currentExposure && 
      currentExposure.tenthPercentile > 0 && 
      currentExposure.mostLikely > 0 && 
      currentExposure.ninetiethPercentile > 0) {
    
    console.log("Using pre-calculated risk summary data:", currentExposure);
    
    return {
      tenthPercentile: currentExposure.tenthPercentile,
      mostLikely: currentExposure.mostLikely,
      ninetiethPercentile: currentExposure.ninetiethPercentile,
      minimum: currentExposure.tenthPercentile, // Use 10th percentile as minimum
      maximum: currentExposure.ninetiethPercentile, // Use 90th percentile as maximum
      average: currentExposure.mostLikely // Most likely is average
    };
  }
  
  // If no risks or exposure data available, return zeros
  if (!risks || risks.length === 0) {
    return {
      tenthPercentile: 0,
      mostLikely: 0,
      ninetiethPercentile: 0,
      minimum: 0,
      maximum: 0,
      average: 0
    };
  }

  // 1. Calculate summed min, avg, max values across all risks
  let sumMin = 0;
  let sumAvg = 0;
  let sumMax = 0;

  // Sum the min, avg, max values from all risks
  risks.forEach(risk => {
    // Log the available risk fields for debugging
    if (risks.indexOf(risk) === 0) {
      console.log("Risk fields available for calculation:", 
        Object.keys(risk).filter(k => 
          k.includes('Loss') || 
          k.includes('Magnitude') || 
          k.includes('Risk') || 
          k.includes('magnitude')
        )
      );
    }
    
    // Try to use all possible loss magnitude or risk fields that might be available
    const minValue = 
      risk.primaryLossMagnitudeMin || 
      risk.lossMagnitudeMin || 
      risk.inherentRiskMin || 
      risk.annualizedLossMin || 
      (risk.residualRisk ? risk.residualRisk * 0.7 : 0); // 70% of residual risk as minimum
    
    const avgValue = 
      risk.primaryLossMagnitudeAvg || 
      risk.lossMagnitudeAvg || 
      risk.inherentRiskAvg || 
      risk.annualizedLossAvg || 
      risk.residualRisk || 
      0;
    
    const maxValue = 
      risk.primaryLossMagnitudeMax || 
      risk.lossMagnitudeMax || 
      risk.inherentRiskMax || 
      risk.annualizedLossMax || 
      (risk.residualRisk ? risk.residualRisk * 1.3 : 0); // 130% of residual risk as maximum
    
    console.log(`Risk "${risk.name}" values - Min: ${minValue}, Avg: ${avgValue}, Max: ${maxValue}`);
    
    // Accumulate the totals
    sumMin += minValue;
    sumAvg += avgValue;
    sumMax += maxValue;
  });

  // 2. Now use these aggregated values for the percentiles
  return {
    tenthPercentile: sumMin, // 10th percentile corresponds to minimum
    mostLikely: sumAvg, // Most likely corresponds to average
    ninetiethPercentile: sumMax, // 90th percentile corresponds to maximum
    minimum: sumMin,
    maximum: sumMax,
    average: sumAvg
  };
};

/**
 * Default tolerance thresholds - these can be edited by the user
 */
// Set thresholds relative to the high-end of the risk data
// Looking at the console logs, we see values like $90M, $57M, $63M
// so set our max threshold at around $500M
const DEFAULT_THRESHOLDS = {
  FULL_ACCEPTANCE: 10000000,      // 100% probability at $10M
  HIGH_ACCEPTANCE: 50000000,      // 75% probability at $50M
  LOW_ACCEPTANCE: 100000000,      // 25% probability at $100M
  ZERO_ACCEPTANCE: 500000000      // 0% probability at $500M+
};

export function LossExceedanceCurve({ 
  risks = [], 
  currentExposure,
  previousExposure 
}: LossExceedanceCurveProps) {

  // Custom editable tolerance thresholds
  const [thresholds, setThresholds] = useState({
    FULL_ACCEPTANCE: DEFAULT_THRESHOLDS.FULL_ACCEPTANCE,
    HIGH_ACCEPTANCE: DEFAULT_THRESHOLDS.HIGH_ACCEPTANCE,
    LOW_ACCEPTANCE: DEFAULT_THRESHOLDS.LOW_ACCEPTANCE,
    ZERO_ACCEPTANCE: DEFAULT_THRESHOLDS.ZERO_ACCEPTANCE
  });
  
  // UI state (removed useLinearScale since we're defaulting to linear scale)
  const [showPreviousData, setShowPreviousData] = useState(!!previousExposure);
  const [showToleranceCurve, setShowToleranceCurve] = useState(true);
  const [useLinearCurve, setUseLinearCurve] = useState(true); // Whether to use linear or non-linear tolerance curve

  // State to manage chart data
  // Removed state variable to avoid shadowing with useMemo below
  const [maxExposure, setMaxExposure] = useState(0);
  
  // If currentExposure is not provided, calculate it from risks data
  const exposureData = generateSummaryData(risks);
  
  // Data validation - ensure we have valid values in the exposure data
  // Log and debug the actual data we're working with
  console.log("Current exposure from API:", currentExposure);
  console.log("Calculated exposure from risks:", exposureData);
  
  // Map the API data to the expected format, including minimum, maximum, and average
  // Create a standardized format for exposure data that will be used throughout the component
  // Ensure all properties are consistently available regardless of source
  const exposureDataFormatted = currentExposure ? {
    tenthPercentile: currentExposure.tenthPercentile || 0,
    mostLikely: currentExposure.mostLikely || 0,
    ninetiethPercentile: currentExposure.ninetiethPercentile || 0,
    minimum: currentExposure.minimumExposure || currentExposure.tenthPercentile || 0,
    maximum: currentExposure.maximumExposure || currentExposure.ninetiethPercentile || 0,
    average: currentExposure.averageExposure || currentExposure.mostLikely || 0
  } : exposureData;
  
  // Ensure we actually have valid data - if not fall back to calculated values from risks
  if (exposureDataFormatted.mostLikely === 0 && exposureDataFormatted.ninetiethPercentile === 0 && exposureData.mostLikely > 0) {
    console.log("Using calculated exposure data because currentExposure values are all zero");
    exposureDataFormatted.tenthPercentile = exposureData.tenthPercentile;
    exposureDataFormatted.mostLikely = exposureData.mostLikely;
    exposureDataFormatted.ninetiethPercentile = exposureData.ninetiethPercentile;
    exposureDataFormatted.minimum = exposureData.minimum;
    exposureDataFormatted.maximum = exposureData.maximum;
    exposureDataFormatted.average = exposureData.average;
  }
  
  // Define previous data points if not provided, including min/max/avg
  const previous = previousExposure ? {
    tenthPercentile: previousExposure.tenthPercentile || 0,
    mostLikely: previousExposure.mostLikely || 0,
    ninetiethPercentile: previousExposure.ninetiethPercentile || 0,
    minimum: previousExposure.minimumExposure || previousExposure.tenthPercentile || 0,
    maximum: previousExposure.maximumExposure || previousExposure.ninetiethPercentile || 0,
    average: previousExposure.averageExposure || previousExposure.mostLikely || 0
  } : {
    // If no previous data available, use current data with a slight increase
    // This ensures we're still showing real proportion relationships without making up data
    tenthPercentile: exposureDataFormatted.tenthPercentile * 1.1,
    mostLikely: exposureDataFormatted.mostLikely * 1.1, 
    ninetiethPercentile: exposureDataFormatted.ninetiethPercentile * 1.1,
    minimum: exposureDataFormatted.minimum * 1.1,
    maximum: exposureDataFormatted.maximum * 1.1,
    average: exposureDataFormatted.average * 1.1
  };
  
  // Memoize the curve data to avoid recomputing on every render
  const memoizedCurveData = useMemo(() => {
    console.log("Generating curve data with exposure data:", exposureDataFormatted);
    
    // Instead of using Monte Carlo simulation, directly create data points using the actual exposure values
    // This ensures we're showing the real risk data from the database
    const directCurveData = [];
    
    // Use 30 points for a smooth curve
    const numPoints = 30;
    
    // Use the actual exposure values from the database for min/max range
    const minExposure = exposureDataFormatted.minimum || exposureDataFormatted.tenthPercentile || 0;
    const maxExposure = exposureDataFormatted.maximum || exposureDataFormatted.ninetiethPercentile || thresholds.ZERO_ACCEPTANCE;
    const avgExposure = exposureDataFormatted.average || exposureDataFormatted.mostLikely || 0;
    
    console.log("Using direct exposure values - Min:", minExposure, "Avg:", avgExposure, "Max:", maxExposure);
    
    // Only create the curve if we have valid exposure data
    if (maxExposure > 0) {
      // Create evenly distributed points between 0 and maxExposure
      for (let i = 0; i <= numPoints; i++) {
        // Calculate loss exposure point (x-axis value)
        const lossExposure = i * (maxExposure / numPoints);
        
        // Map probability based on position relative to the exposure values (y-axis value)
        // This gives us a standard Loss Exceedance Curve shape:
        // - At $0: 100% probability of exceeding
        // - At minimum exposure (10th percentile): 90% probability
        // - At average exposure (50th percentile): 50% probability
        // - At maximum exposure (90th percentile): 10% probability
        // - Above maximum: approaching 0% probability
        
        let probability;
        
        if (lossExposure <= 0) {
          probability = 100; // 100% probability of exceeding $0
        } 
        else if (lossExposure <= minExposure) {
          // Between $0 and minimum: probability drops from 100% to 90%
          probability = 100 - ((lossExposure / minExposure) * 10);
        } 
        else if (lossExposure <= avgExposure) {
          // Between minimum and average: probability drops from 90% to 50%
          const positionRatio = (lossExposure - minExposure) / (avgExposure - minExposure);
          probability = 90 - (positionRatio * 40);
        } 
        else if (lossExposure <= maxExposure) {
          // Between average and maximum: probability drops from 50% to 10%
          const positionRatio = (lossExposure - avgExposure) / (maxExposure - avgExposure);
          probability = 50 - (positionRatio * 40);
        } 
        else {
          // Above maximum: probability approaches 0%
          probability = Math.max(0, 10 - ((lossExposure - maxExposure) / (maxExposure * 0.2)) * 10);
        }
        
        // Determine tolerance level based on thresholds
        let toleranceLevel = 0;
        if (lossExposure <= thresholds.FULL_ACCEPTANCE) {
          toleranceLevel = 100;
        } else if (lossExposure <= thresholds.HIGH_ACCEPTANCE) {
          toleranceLevel = 75;
        } else if (lossExposure <= thresholds.LOW_ACCEPTANCE) {
          toleranceLevel = 25;
        }
        
        // Add the data point to our curve
        directCurveData.push({
          lossExposure,
          probability,
          previousProbability: previous ? Math.min(100, probability * 1.1) : null,
          toleranceProbability: toleranceLevel,
          unacceptableRisk: probability > toleranceLevel ? toleranceLevel : 0,
          formattedLoss: formatExposure(lossExposure)
        });
      }
      
      // Add key exposure values as explicit points to ensure they're displayed
      // 10th percentile (minimum)
      directCurveData.push({
        lossExposure: minExposure,
        probability: 90,
        previousProbability: previous ? 95 : null,
        toleranceProbability: minExposure <= thresholds.FULL_ACCEPTANCE ? 100 : 
                             minExposure <= thresholds.HIGH_ACCEPTANCE ? 75 :
                             minExposure <= thresholds.LOW_ACCEPTANCE ? 25 : 0,
        unacceptableRisk: 0,
        formattedLoss: formatExposure(minExposure)
      });
      
      // 50th percentile (average/most likely)
      directCurveData.push({
        lossExposure: avgExposure,
        probability: 50,
        previousProbability: previous ? 55 : null,
        toleranceProbability: avgExposure <= thresholds.FULL_ACCEPTANCE ? 100 : 
                             avgExposure <= thresholds.HIGH_ACCEPTANCE ? 75 :
                             avgExposure <= thresholds.LOW_ACCEPTANCE ? 25 : 0,
        unacceptableRisk: 0,
        formattedLoss: formatExposure(avgExposure)
      });
      
      // 90th percentile (maximum)
      directCurveData.push({
        lossExposure: maxExposure,
        probability: 10,
        previousProbability: previous ? 15 : null,
        toleranceProbability: maxExposure <= thresholds.FULL_ACCEPTANCE ? 100 : 
                             maxExposure <= thresholds.HIGH_ACCEPTANCE ? 75 :
                             maxExposure <= thresholds.LOW_ACCEPTANCE ? 25 : 0,
        unacceptableRisk: 0,
        formattedLoss: formatExposure(maxExposure)
      });
      
      // Sort by lossExposure to ensure proper curve rendering
      directCurveData.sort((a, b) => a.lossExposure - b.lossExposure);
      
      console.log("Direct curve data points:", directCurveData.length);
      console.log("Sample direct curve data point:", directCurveData[0]);
      
      return {
        curveData: directCurveData,
        maxExposure: maxExposure * 1.2 // Add some margin to the max for the chart
      };
    }
    
    // Fallback if no valid exposure data - create a basic curve with tolerance thresholds
    const fallbackCurveData = [];
    const pointsCount = 10;
    
    console.log("Creating fallback curve data using thresholds");
    
    // Use the maximum threshold value for the range
    const maxValue = thresholds.ZERO_ACCEPTANCE;
    
    for (let i = 0; i <= pointsCount; i++) {
      const lossPoint = i * (maxValue / pointsCount);
      
      // Default decreasing linear probability
      const probabilityValue = 100 - (i / pointsCount) * 100;
      
      // Determine tolerance level based on thresholds
      let toleranceLevel = 0;
      if (lossPoint <= thresholds.FULL_ACCEPTANCE) {
        toleranceLevel = 100;
      } else if (lossPoint <= thresholds.HIGH_ACCEPTANCE) {
        toleranceLevel = 75;
      } else if (lossPoint <= thresholds.LOW_ACCEPTANCE) {
        toleranceLevel = 25;
      }
      
      fallbackCurveData.push({
        lossExposure: lossPoint,
        probability: probabilityValue,
        previousProbability: Math.min(100, probabilityValue * 1.15),
        toleranceProbability: toleranceLevel,
        unacceptableRisk: probabilityValue > toleranceLevel ? toleranceLevel : 0,
        formattedLoss: formatExposure(lossPoint)
      });
    }
    
    return {
      curveData: fallbackCurveData,
      maxExposure: maxValue
    };    
  }, [
    risks, 
    thresholds.FULL_ACCEPTANCE,
    thresholds.HIGH_ACCEPTANCE,
    thresholds.LOW_ACCEPTANCE,
    thresholds.ZERO_ACCEPTANCE,
    useLinearCurve,
    exposureDataFormatted,
    previous
  ]);
  
  // Process the curve data
  const { curveData } = memoizedCurveData || { curveData: [] };
  
  // Sort and prepare combined data for the chart
  const combinedData = useMemo(() => {
    // Log the data we'll be using for the chart
    console.log("Loss Exceedance Curve data:", curveData.length);
    if (curveData.length > 0) {
      console.log("Sample data point:", curveData[0]);
    }
    
    return curveData;
  }, [curveData]);
  
  // Format the total exposure value for easy display
  const formattedCurrentExposure = useMemo(() => {
    const exposureValue = exposureDataFormatted?.mostLikely || 0;
    return formatExposure(exposureValue);
  }, [exposureDataFormatted]);
  
  // Format the total max exposure for display
  const formattedMaxExposure = useMemo(() => {
    const maxExposureValue = exposureDataFormatted?.maximum || 0;
    return formatExposure(maxExposureValue);
  }, [exposureDataFormatted]);
  
  // Format the total min exposure for display
  const formattedMinExposure = useMemo(() => {
    const minExposureValue = exposureDataFormatted?.minimum || 0;
    return formatExposure(minExposureValue);
  }, [exposureDataFormatted]);
  
  // Format the current percentiles for display
  const formattedTenthPercentile = useMemo(() => {
    return formatExposure(exposureDataFormatted?.tenthPercentile || 0);
  }, [exposureDataFormatted]);
  
  const formattedNinetiethPercentile = useMemo(() => {
    return formatExposure(exposureDataFormatted?.ninetiethPercentile || 0);
  }, [exposureDataFormatted]);

  // We're now using the memoized curveData directly without useState/useEffect
  // This helps us avoid redundancy and potential issues with stale state
  
  // Update maxExposure directly from memoized data
  useEffect(() => {
    // Set the max exposure for the chart scaling
    if (memoizedCurveData && memoizedCurveData.maxExposure) {
      setMaxExposure(memoizedCurveData.maxExposure);
    }
    
    // Log complete summary of the data we're using (for debugging purposes)
    console.log("Risk summary data loaded:", {
      minExposure: formattedMinExposure,
      currentExposure: formattedCurrentExposure,
      maxExposure: formattedMaxExposure,
      tenthPercentile: formattedTenthPercentile,
      ninetiethPercentile: formattedNinetiethPercentile,
      dataPoints: memoizedCurveData.curveData?.length
    });
  }, [
    risks,
    currentExposure,
    previousExposure
  ]);

  // We use the formatExposure function defined at the top level of this file for currency display
  
  // Format percent change between current and previous values
  const formatPercentChange = (current: number | undefined, previous: number | undefined) => {
    if (!current || !previous) return '0%';
    if (previous === 0) return 'N/A';
    
    const change = ((current - previous) / previous) * 100;
    return `${Math.abs(change).toFixed(1)}%`;
  };
  
  // Format raw number for input field display (no currency symbol or suffixes)
  const formatInputValue = (value: number | undefined) => {
    if (value === undefined) return '';
    return value.toString();
  };
  
  // Handler for updating threshold values
  const updateThreshold = (key: string, value: number) => {
    setThresholds((prev) => {
      const newThresholds = {
        ...prev,
        [key]: value
      };
      return newThresholds;
    });
  };
  
  return (
    <Card>
      <CardHeader className="pb-0">
        <CardTitle className="text-lg font-semibold text-card-foreground">
          Loss Exceedance Curve
        </CardTitle>
        <div className="flex items-center justify-end space-x-4">
          <div className="flex items-center space-x-2">
            <span className="text-sm text-muted-foreground">Show Historical Comparison</span>
            <Switch 
              checked={showPreviousData} 
              onCheckedChange={setShowPreviousData}
              disabled={!previousExposure}
            />
          </div>
          <div className="flex items-center space-x-2">
            <span className="text-sm text-muted-foreground">Show Tolerance Curve</span>
            <Switch 
              checked={showToleranceCurve} 
              onCheckedChange={setShowToleranceCurve} 
            />
          </div>
          {/* Removed Linear Scale toggle since we're using linear scale by default */}
        </div>
      </CardHeader>
      <CardContent>
        <div className="grid grid-cols-1 md:grid-cols-2 gap-4 mb-6">
          {/* Current Exposure Card */}
          <div className="bg-card p-4 rounded-lg border border-border">
            <div className="flex items-center mb-2">
              <div className="h-3 w-3 rounded-full bg-primary mr-2"></div>
              <h3 className="text-sm font-medium text-card-foreground">Current Annualized Loss Exposure</h3>
            </div>
            <div className="grid grid-cols-3 gap-4 mt-2">
              <div className="text-center">
                <p className="text-xs text-muted-foreground">10th Percentile</p>
                <p className="text-xl font-bold text-card-foreground">{formatExposure(exposureDataFormatted.tenthPercentile)}</p>
                <p className="text-xs text-muted-foreground/70">Minimum {formatExposure(exposureDataFormatted.minimum)}</p>
                {previousExposure && showPreviousData && (
                  <div className={`mt-1 text-xs ${exposureDataFormatted.tenthPercentile > previous.tenthPercentile ? 'text-red-500' : 'text-green-500'}`}>
                    {exposureDataFormatted.tenthPercentile > previous.tenthPercentile ? '↑' : '↓'} {formatPercentChange(exposureDataFormatted.tenthPercentile, previous.tenthPercentile)}
                  </div>
                )}
              </div>
              <div className="text-center">
                <p className="text-xs text-muted-foreground">Most Likely</p>
                <p className="text-xl font-bold text-card-foreground">{formatExposure(exposureDataFormatted.mostLikely)}</p>
                <p className="text-xs text-muted-foreground/70">Average {formatExposure(exposureDataFormatted.average)}</p>
                {previousExposure && showPreviousData && (
                  <div className={`mt-1 text-xs ${exposureDataFormatted.mostLikely > previous.mostLikely ? 'text-red-500' : 'text-green-500'}`}>
                    {exposureDataFormatted.mostLikely > previous.mostLikely ? '↑' : '↓'} {formatPercentChange(exposureDataFormatted.mostLikely, previous.mostLikely)}
                  </div>
                )}
              </div>
              <div className="text-center">
                <p className="text-xs text-muted-foreground">90th Percentile</p>
                <p className="text-xl font-bold text-card-foreground">{formatExposure(exposureDataFormatted.ninetiethPercentile)}</p>
                <p className="text-xs text-muted-foreground/70">Maximum {formatExposure(exposureDataFormatted.maximum)}</p>
                {previousExposure && showPreviousData && (
                  <div className={`mt-1 text-xs ${exposureDataFormatted.ninetiethPercentile > previous.ninetiethPercentile ? 'text-red-500' : 'text-green-500'}`}>
                    {exposureDataFormatted.ninetiethPercentile > previous.ninetiethPercentile ? '↑' : '↓'} {formatPercentChange(exposureDataFormatted.ninetiethPercentile, previous.ninetiethPercentile)}
                  </div>
                )}
              </div>
            </div>
          </div>
          
          {/* Previous Exposure Card (conditionally rendered) */}
          {showPreviousData && (
            <div className="bg-card p-4 rounded-lg border border-border">
              <div className="flex items-center mb-2">
                <div className="h-3 w-3 rounded-full bg-amber-500 mr-2"></div>
                <h3 className="text-sm font-medium text-card-foreground">Previous Annualized Loss Exposure</h3>
              </div>
              <div className="grid grid-cols-3 gap-4 mt-2">
                <div className="text-center">
                  <p className="text-xs text-muted-foreground">10th Percentile</p>
                  <p className="text-xl font-bold text-card-foreground">{formatExposure(previous.tenthPercentile)}</p>
                  <p className="text-xs text-muted-foreground/70">Minimum {formatExposure(previous.minimum)}</p>
                </div>
                <div className="text-center">
                  <p className="text-xs text-muted-foreground">Most Likely</p>
                  <p className="text-xl font-bold text-card-foreground">{formatExposure(previous.mostLikely)}</p>
                  <p className="text-xs text-muted-foreground/70">Average {formatExposure(previous.average)}</p>
                </div>
                <div className="text-center">
                  <p className="text-xs text-muted-foreground">90th Percentile</p>
                  <p className="text-xl font-bold text-card-foreground">{formatExposure(previous.ninetiethPercentile)}</p>
                  <p className="text-xs text-muted-foreground/70">Maximum {formatExposure(previous.maximum)}</p>
                </div>
              </div>
            </div>
          )}
        </div>
        
        {/* Risk Tolerance Profile */}
        <div className="mb-6 p-4 border border-border rounded-lg">
          <div className="flex justify-between items-center mb-4">
            <h3 className="text-sm font-medium text-card-foreground">Risk Tolerance Profile</h3>
            <div className="flex items-center space-x-2">
              <span className="text-sm text-muted-foreground">Linear Curve</span>
              <Switch 
                checked={useLinearCurve} 
                onCheckedChange={setUseLinearCurve} 
              />
            </div>
          </div>
          
          <div className="grid grid-cols-1 gap-4">
            {/* Editable Threshold Cards */}
            <div className="grid grid-cols-2 md:grid-cols-4 gap-2 mb-4">
              <div className="bg-primary/5 border border-primary/20 rounded-lg p-3 shadow-sm">
                <p className="text-sm font-medium text-primary">100% acceptable</p>
                <div className="flex flex-col">
                  <Input 
                    type="text" 
                    value={formatInputValue(thresholds.FULL_ACCEPTANCE)} 
                    onChange={(e) => {
                      // Extract only numbers from the input
                      const rawValue = e.target.value.replace(/[^0-9]/g, '');
                      // Use Number() instead of parseInt to handle larger values
                      const value = Number(rawValue);
                      if (!isNaN(value)) {
                        updateThreshold('FULL_ACCEPTANCE', value);
                      }
                    }} 
                    className="text-sm mt-1 text-right font-bold" 
                  />
                  <span className="text-xs text-muted-foreground mt-1">Formatted: {formatExposure(thresholds.FULL_ACCEPTANCE)}</span>
                </div>
              </div>
              
              <div className="bg-primary/5 border border-primary/20 rounded-lg p-3 shadow-sm">
                <p className="text-sm font-medium text-primary">75% acceptable</p>
                <div className="flex flex-col">
                  <Input 
                    type="text" 
                    value={formatInputValue(thresholds.HIGH_ACCEPTANCE)} 
                    onChange={(e) => {
                      // Extract only numbers from the input
                      const rawValue = e.target.value.replace(/[^0-9]/g, '');
                      // Use Number() instead of parseInt to handle larger values
                      const value = Number(rawValue);
                      if (!isNaN(value)) {
                        updateThreshold('HIGH_ACCEPTANCE', value);
                      }
                    }} 
                    className="text-sm mt-1 text-right font-bold" 
                  />
                  <span className="text-xs text-muted-foreground mt-1">Formatted: {formatExposure(thresholds.HIGH_ACCEPTANCE)}</span>
                </div>
              </div>
              
              <div className="bg-primary/5 border border-primary/20 rounded-lg p-3 shadow-sm">
                <p className="text-sm font-medium text-primary">25% acceptable</p>
                <div className="flex flex-col">
                  <Input 
                    type="text" 
                    value={formatInputValue(thresholds.LOW_ACCEPTANCE)} 
                    onChange={(e) => {
                      // Extract only numbers from the input
                      const rawValue = e.target.value.replace(/[^0-9]/g, '');
                      // Use Number() instead of parseInt to handle larger values
                      const value = Number(rawValue);
                      if (!isNaN(value)) {
                        updateThreshold('LOW_ACCEPTANCE', value);
                      }
                    }} 
                    className="text-sm mt-1 text-right font-bold" 
                  />
                  <span className="text-xs text-muted-foreground mt-1">Formatted: {formatExposure(thresholds.LOW_ACCEPTANCE)}</span>
                </div>
              </div>
              
              <div className="bg-destructive/5 border border-destructive/20 rounded-lg p-3 shadow-sm">
                <p className="text-sm font-medium text-destructive">0% acceptable</p>
                <div className="flex flex-col">
                  <Input 
                    type="text" 
                    value={formatInputValue(thresholds.ZERO_ACCEPTANCE)} 
                    onChange={(e) => {
                      // Extract only numbers from the input
                      const rawValue = e.target.value.replace(/[^0-9]/g, '');
                      // Use Number() instead of parseInt to handle larger values
                      const value = Number(rawValue);
                      if (!isNaN(value)) {
                        updateThreshold('ZERO_ACCEPTANCE', value);
                      }
                    }} 
                    className="text-sm mt-1 text-right font-bold" 
                  />
                  <span className="text-xs text-muted-foreground mt-1">Formatted: {formatExposure(thresholds.ZERO_ACCEPTANCE)}</span>
                </div>
              </div>
            </div>
          </div>
        </div>
        
        {/* Loss Exceedance Curve Chart */}
        <div className="h-[450px]">
          <ResponsiveContainer width="100%" height="100%">
            <LineChart
              data={memoizedCurveData.curveData?.length > 0 ? memoizedCurveData.curveData : []}
              margin={{ top: 15, right: 20, left: 15, bottom: 30 }}
            >
              <CartesianGrid 
                strokeDasharray="3 3" 
                stroke="var(--border)" 
                horizontal={true}
                vertical={true}
                horizontalPoints={[0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100]} // Match Y-axis ticks
                verticalPoints={[0, 50000000, 100000000, 150000000, 200000000, 250000000, 300000000, 350000000]} // Match X-axis ticks
              />
              <XAxis 
                dataKey="lossExposure" 
                name="Financial Impact"
                type="number" 
                scale="linear"
                // Set domain based on actual loss exposure values - start at 0 and increment by 50M
                domain={[0, 'dataMax']} 
                tickFormatter={(value) => formatExposure(value)}
                axisLine={{ stroke: 'var(--border)', strokeWidth: 2 }}
                label={{ value: 'Loss Exposure', position: 'insideBottom', offset: -10, fill: 'var(--foreground)' }}
                tick={props => <CustomXAxisTick {...props} formatter={formatExposure} />}
                // Create evenly spaced ticks at $50M intervals up to $350M to better visualize all risks
                ticks={[0, 50000000, 100000000, 150000000, 200000000, 250000000, 300000000, 350000000]}
              />
              <YAxis 
                domain={[0, 100]}
                tickCount={11} // 0%, 10%, 20%, ..., 100%
                ticks={[0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100]} // Explicitly set ticks
                tickFormatter={(value) => `${value}%`}
                axisLine={{ stroke: 'var(--border)', strokeWidth: 2 }}
                label={{ value: 'Probability of Loss or Greater', angle: -90, position: 'insideLeft', offset: -5, fill: 'var(--foreground)' }}
                width={45}
              />
              <Tooltip 
                content={({ active, payload }) => {
                  if (active && payload && payload.length) {
                    // Get the lossExposure from the payload
                    const lossValue = payload[0].payload.lossExposure;

                    return (
                      <div className="bg-card p-2 border border-border shadow-md rounded-md">
                        <p className="font-semibold text-xs text-card-foreground">{formatExposure(lossValue)}</p>
                        
                        {payload.map((entry, index) => {
                          if (entry.dataKey === 'lossExposure') return null;
                          
                          // For probability values
                          if (entry.dataKey === 'probability') {
                            // Calculate financial impact based on the probability
                            const value = entry.value || 0;
                            const probability = Math.round(value * 100) / 100;
                            
                            return (
                              <p key={`current-prob-${index}`} className="text-card-foreground text-xs" style={{ color: entry.color }}>
                                Current: {probability}%
                              </p>
                            );
                          }
                          
                          // For previous probability values
                          if (entry.dataKey === 'previousProbability') {
                            // Calculate financial impact based on the probability
                            const value = entry.value || 0;
                            const probability = Math.round(value * 100) / 100;
                            
                            return (
                              <p key={`prev-prob-${index}`} className="text-card-foreground text-xs" style={{ color: entry.color }}>
                                Previous: {probability}%
                              </p>
                            );
                          }
                          
                          // For tolerance values, simplified to just show value
                          if (entry.dataKey === 'toleranceProbability') {
                            const value = entry.value || 0;
                            const tolerance = Math.round(value * 100) / 100;
                            return (
                              <p key={`tolerance-prob-${index}`} className="text-card-foreground text-xs" style={{ color: entry.color }}>
                                Tolerance: {tolerance}%
                              </p>
                            );
                          }
                          
                          return null;
                        })}
                      </div>
                    );
                  }
                  return null;
                }}
              />
              <Legend />
              
              {/* Add reference lines for key percentile points */}
              {exposureDataFormatted && (
                <>
                  {/* 10th Percentile Reference Line */}
                  <ReferenceLine 
                    x={exposureDataFormatted.minimum || exposureDataFormatted.tenthPercentile} 
                    stroke="#6B7280" 
                    strokeDasharray="3 3"
                    label={{ 
                      value: `10th Percentile (${formatExposure(exposureDataFormatted.minimum || exposureDataFormatted.tenthPercentile)})`, 
                      position: 'top', 
                      fill: 'var(--muted-foreground)',
                      fontSize: 10
                    }} 
                  />
                  
                  {/* 50th Percentile / Most Likely Reference Line */}
                  <ReferenceLine 
                    x={exposureDataFormatted.average || exposureDataFormatted.mostLikely} 
                    stroke="#6B7280" 
                    strokeDasharray="3 3"
                    label={{ 
                      value: `50th Percentile (${formatExposure(exposureDataFormatted.average || exposureDataFormatted.mostLikely)})`, 
                      position: 'top', 
                      fill: 'var(--muted-foreground)',
                      fontSize: 10
                    }} 
                  />
                  
                  {/* 90th Percentile Reference Line */}
                  <ReferenceLine 
                    x={exposureDataFormatted.maximum || exposureDataFormatted.ninetiethPercentile} 
                    stroke="#6B7280" 
                    strokeDasharray="3 3"
                    label={{ 
                      value: `90th Percentile (${formatExposure(exposureDataFormatted.maximum || exposureDataFormatted.ninetiethPercentile)})`, 
                      position: 'top', 
                      fill: 'var(--muted-foreground)',
                      fontSize: 10
                    }} 
                  />
                </>
              )}
              
              {/* Risk tolerance curve - render this first so it appears behind other lines */}
              {showToleranceCurve && (
                <Line 
                  type="natural" 
                  dataKey="toleranceProbability" 
                  stroke="#10B981" 
                  strokeWidth={2}
                  dot={false}
                  isAnimationActive={false}
                  name="Risk Tolerance"
                  connectNulls={true}
                />
              )}
              
              {/* Previous Loss Probability Curve */}
              {showPreviousData && (
                <Line 
                  type="natural" 
                  dataKey="previousProbability" 
                  stroke="#EAB308" 
                  strokeWidth={2}
                  dot={false}
                  isAnimationActive={false}
                  strokeDasharray="5 5"
                  name="Previous Loss Probability"
                  connectNulls={true}
                />
              )}
              
              {/* Add an area to highlight unacceptable risk gap between curves */}
              {/* Add special reference areas for the key threshold boundaries */}
              {!useLinearCurve && showToleranceCurve && (
                <>
                  {/* Add vertical highlighting for risk thresholds */}
                  <ReferenceArea
                    x1={thresholds.FULL_ACCEPTANCE}
                    x2={thresholds.HIGH_ACCEPTANCE}
                    y1={75}
                    y2={100}
                    fill="#DCF7EE"
                    fillOpacity={0.2}
                    stroke="#10B981"
                    strokeWidth={1}
                    strokeDasharray="2 2"
                  />
                  <ReferenceArea
                    x1={thresholds.HIGH_ACCEPTANCE}
                    x2={thresholds.LOW_ACCEPTANCE}
                    y1={25}
                    y2={75}
                    fill="#DCF7EE"
                    fillOpacity={0.2}
                    stroke="#10B981"
                    strokeWidth={1}
                    strokeDasharray="2 2"
                  />
                  <ReferenceArea
                    x1={thresholds.LOW_ACCEPTANCE}
                    x2={thresholds.ZERO_ACCEPTANCE}
                    y1={0}
                    y2={25}
                    fill="#DCF7EE"
                    fillOpacity={0.2}
                    stroke="#10B981"
                    strokeWidth={1}
                    strokeDasharray="2 2"
                  />
                </>
              )}
              
              {/* Using a custom curve to highlight unacceptable risk between probability and tolerance */}
              {combinedData.map((entry, index) => {
                // Only draw areas where probability exceeds tolerance (unacceptable risk)
                if (entry.probability <= entry.toleranceProbability || index === 0) {
                  return null;
                }
                
                return (
                  <ReferenceArea
                    key={`risk-area-${index}`}
                    x1={entry.lossExposure}
                    x2={combinedData[index - 1]?.lossExposure}
                    y1={entry.toleranceProbability}
                    y2={entry.probability}
                    fill="#F87171"
                    fillOpacity={0.4}
                    stroke="none"
                  />
                );
              })}
              
              {/* Current Loss Probability Curve - render last so it appears on top */}
              <Line 
                type="natural" 
                dataKey="probability" 
                stroke="#3B82F6" 
                activeDot={{ r: 6 }} 
                strokeWidth={3}
                dot={false}
                isAnimationActive={false}
                name="Current Loss Probability"
                connectNulls={true}
              />
              
              {/* Reference lines for key thresholds - simplified */}
              {showToleranceCurve && (
                <>
                  {/* Vertical reference lines only to reduce chart complexity */}
                  <ReferenceLine 
                    x={thresholds.FULL_ACCEPTANCE} 
                    stroke="#10B981" 
                    strokeDasharray="3 3" 
                  />
                  {!useLinearCurve && (
                    <>
                      <ReferenceLine 
                        x={thresholds.HIGH_ACCEPTANCE} 
                        stroke="#10B981" 
                        strokeDasharray="3 3" 
                      />
                      <ReferenceLine 
                        x={thresholds.LOW_ACCEPTANCE} 
                        stroke="#10B981" 
                        strokeDasharray="3 3" 
                      />
                    </>
                  )}
                  <ReferenceLine 
                    x={thresholds.ZERO_ACCEPTANCE} 
                    stroke="#10B981" 
                    strokeDasharray="3 3" 
                  />
                </>
              )}
            </LineChart>
          </ResponsiveContainer>
        </div>
        
        {/* Annotations */}
        <div className="mt-4 grid grid-cols-2 md:grid-cols-4 gap-4">
          <div className="text-sm text-gray-600">
            <span className="inline-block w-3 h-3 bg-blue-500 mr-2"></span>
            Current Loss Probability
          </div>
          {showToleranceCurve && (
            <div className="text-sm text-gray-600">
              <span className="inline-block w-3 h-3 bg-green-500 mr-2"></span>
              Risk Tolerance Profile ({useLinearCurve ? 'linear' : 'non-linear'})
            </div>
          )}
          {showPreviousData && (
            <div className="text-sm text-gray-600">
              <span className="inline-block w-3 h-3 bg-yellow-400 mr-2"></span>
              Previous Loss Probability
            </div>
          )}
          <div className="text-sm text-gray-600">
            <span className="inline-block w-3 h-3 bg-red-300 mr-2"></span>
            Unacceptable Risk Area
          </div>
        </div>
      </CardContent>
    </Card>
  );
}