To eliminate these spikes, standardize your tolerance curve to rely exclusively on the fixed organizational thresholds (toleranceThresholds), and remove the inconsistent data-driven thresholds.

Replace this problematic section:
typescript
Copy
// Calculate threshold probability with smooth gradients
let toleranceProbability;

// Use the same data-driven tolerance calculation as the main loop
const dataMinThreshold = minExposure * 0.8;
const dataLowThreshold = avgExposure * 0.6;
const dataMedThreshold = avgExposure * 1.0;
const dataHighThreshold = avgExposure * 1.4;
const dataMaxThreshold = maxExposure * 0.8;

// (your interpolation logic using these dynamic values...)
âœ… With consistent logic based exclusively on fixed thresholds:
typescript
Copy
// Standardize tolerance calculation to always use fixed thresholds
if (point <= toleranceThresholds.fullAcceptance) {
  toleranceProbability = 100;
} else if (point <= toleranceThresholds.highAcceptance) {
  const range = toleranceThresholds.highAcceptance - toleranceThresholds.fullAcceptance;
  const position = point - toleranceThresholds.fullAcceptance;
  toleranceProbability = 100 - (25 * (position / range));
} else if (point <= toleranceThresholds.mediumAcceptance) {
  const range = toleranceThresholds.mediumAcceptance - toleranceThresholds.highAcceptance;
  const position = point - toleranceThresholds.highAcceptance;
  toleranceProbability = 75 - (25 * (position / range));
} else if (point <= toleranceThresholds.lowAcceptance) {
  const range = toleranceThresholds.lowAcceptance - toleranceThresholds.mediumAcceptance;
  const position = point - toleranceThresholds.mediumAcceptance;
  toleranceProbability = 50 - (25 * (position / range));
} else if (point <= toleranceThresholds.zeroAcceptance) {
  const range = toleranceThresholds.zeroAcceptance - toleranceThresholds.lowAcceptance;
  const position = point - toleranceThresholds.lowAcceptance;
  toleranceProbability = 25 - (25 * (position / range));
} else {
  toleranceProbability = 0;
}
