ğŸ“ŒÂ Context

You are an experienced TypeScript developer maintaining a webâ€‘application riskâ€‘analysis backend that currently relies on triangular distributions and coarse user inputs.  The goal of this task is to swap in empiricallyâ€‘derived parameters from the Cyentia IRISÂ 2025 report so that every FAIR (Factor Analysis of Information Risk) simulation run is grounded in upâ€‘toâ€‘date actuarial evidence.

The codebase already contains:

monteCarlo.ts â€” lowâ€‘level randomâ€‘sampler and simulation loop.

fairCamCalculations.ts â€” utility functions that consume Monteâ€‘Carlo results (leave untouched).

riskCalculationAdapter.ts â€” maps UI/json input onto the MonteCarloInput interface.

You will implement five small but surgical changes plus unit tests, without altering any public API beyond the new optional parameters.

âœ…Â Acceptance Criteria

IRIS defaults are applied automatically when the UI does not override TEF / Lossâ€‘Magnitude values.

Logâ€‘normal sampling replaces the triangular primaryâ€‘loss sampler when Âµ/Ïƒ are provided.

All existing risk dashboards render with identical structure; only the underlying figures change.

CI passes (npm test) and new test cases verify that:

logNormal() returns numbers whose geometric mean â‰ˆ e^Âµ.

A 100â€‰kâ€‘run simulation using IRIS defaults produces a 90â€‘percentile loss between 25â€¯MÂ andÂ 32â€¯M (per report).

ğŸ› ï¸Â Implementation Steps

Add IRIS parameter constants*File: *riskCalculationAdapter.ts

// ---- IRIS 2025 actuarial baselines --------------------------
const IRIS_TEF_ALL = { min: 0.025, mode: 0.093, max: 0.12 };       // FigÂ 6, all orgs
const WEBAPP_WEIGHT = 0.38;                                        // FigÂ 8, <Â $100Â M

const IRIS_TEF_WEBAPP = {
  min: IRIS_TEF_ALL.min * WEBAPP_WEIGHT,
  mode: IRIS_TEF_ALL.mode * WEBAPP_WEIGHT,
  max: IRIS_TEF_ALL.max * WEBAPP_WEIGHT,
};

const IRIS_LM_ALL = { mu: Math.log(2_900_000), sigma: 1.95 };      // FigÂ 10, global
const IRIS_LM_SMB = { mu: Math.log(357_000),  sigma: 1.77 };       // FigÂ 10, <Â $100Â M

Choose between IRIS_LM_ALL and IRIS_LM_SMB based on riskData.orgSize.

Extend the interface*File: *monteCarlo.ts

export interface MonteCarloInput {
  /* existing props â€¦ */
  tefMin?: number;  tefMode?: number;  tefMax?: number;
  plMu?: number;    plSigma?: number;
}

Insert two utility samplersAppend to monteCarlo.ts bottom (above exports)

export function logNormal(mu: number, sigma: number): number {
  const u1 = Math.random();
  const u2 = Math.random();
  const z  = Math.sqrt(-2 * Math.log(u1)) * Math.cos(2 * Math.PI * u2);
  return Math.exp(mu + sigma * z);
}

export function betaPert(min: number, mode: number, max: number): number {
  const alpha = 1 + 4 * (mode - min) / (max - min);
  const beta  = 1 + 4 * (max  - mode) / (max - min);
  const u1 = Math.random();
  const u2 = Math.random();
  const y  = Math.pow(u1, 1 / alpha) / (Math.pow(u1, 1 / alpha) + Math.pow(u2, 1 / beta));
  return min + y * (max - min);
}

Modify the simulation loop*Inside runFairCamFullMonteCarlo() in *monteCarlo.ts

// Frequency handling
let cf  = triangular(params.cfMin, params.cfMode, params.cfMax);
let poa = triangular(params.poaMin, params.poaMode, params.poaMax);

if (params.tefMin !== undefined) {
  cf  = 1;  // exactly one annual opportunity
  poa = betaPert(params.tefMin, params.tefMode!, params.tefMax!);
}

// Loss magnitude handling
const primaryLoss = params.plMu !== undefined
  ? logNormal(params.plMu, params.plSigma!)
  : triangular(params.plMin, params.plMode, params.plMax);

Populate new fields in the adapter*Back to *riskCalculationAdapter.ts

monteCarloInput.tefMin  = IRIS_TEF_WEBAPP.min;
monteCarloInput.tefMode = IRIS_TEF_WEBAPP.mode;
monteCarloInput.tefMax  = IRIS_TEF_WEBAPP.max;

const LM = riskData.orgSize === 'SMB' ? IRIS_LM_SMB : IRIS_LM_ALL;
monteCarloInput.plMu    = LM.mu;
monteCarloInput.plSigma = LM.sigma;

ğŸ”¸Â Remove any legacy plMin/plMode/plMax assignments to avoid doubleâ€‘definition.

Write unit tests*File: *__tests__/irisIntegration.spec.ts

Confirm logNormal(Âµ,Ïƒ) produces expected geometric mean.

Simulate 100â€¯k iterations with IRIS defaults and assert p90 is within 25â€“32â€¯M.

Update docsAdd a bullet to CHANGELOG.md under ##Â [Unreleased] explaining â€œIRISâ€¯2025 actuarial data now drives default FAIR parametersâ€.

ğŸ”„Â How to Roll Back

Changing riskCalculationAdapter.ts is the only step that activates IRIS sampling.  To revert, comment out the four monteCarloInput.* lines added in Stepâ€¯5.

ğŸ“…Â Effort Estimate

Task

Hours

Constants & interface

Â 1Â 

Utility functions

Â 0.5

Simulation refactor

Â 1Â 

Adapter wiring

Â 0.5

Unit tests

Â 2Â 

Docs & PR

Â 0.5

Total

5.5Â h

ğŸ—„ï¸Â Industry InsightsÂ Database

Goal
Persist IRISâ€¯2025 (and future) industry metrics so that Monteâ€‘Carlo results can be benchmarked against current sector norms directly inside the application.

ğŸ“Â AcceptanceÂ Criteria

A new industry_insights table exists (PostgreSQL) and is migrated automatically on deploy.

A TypeORM entity + repository exposes upsertInsights(insights: InsightDTO[]) and get(metric, sector) helpers.

A scheduled job syncIndustryInsights.ts parses fresh IRIS/Feedly JSON and upserts rows weekly.

The risk dashboard can query benchmarkService.getPercentile(metric, sector, value) to display Our org vs. Industry gauges.

ğŸ—„ï¸Â DDL (MigrationÂ Script)

CREATE TABLE IF NOT EXISTS industry_insights (
    id              SERIAL PRIMARY KEY,
    sector          VARCHAR(64)  NOT NULL,      -- e.g. "Technology", "Retail"
    metric          VARCHAR(64)  NOT NULL,      -- e.g. "TEF_MEDIAN", "LM_P90"
    value_numeric   NUMERIC,
    value_text      TEXT,
    unit            VARCHAR(16),               -- %, USD, etc.
    source          VARCHAR(128) NOT NULL,     -- "IRIS 2025", "Feedly 2025â€‘Q2"
    effective_from  DATE        NOT NULL,
    effective_to    DATE        DEFAULT '9999-12-31',
    version         INT         NOT NULL DEFAULT 1,
    created_at      TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at      TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    UNIQUE(sector, metric, effective_from)
);

CREATE INDEX IF NOT EXISTS idx_insights_sector_metric ON industry_insights(sector, metric);

ğŸ”¨Â ImplementationÂ Steps

Generate migration via npm run typeorm migration:generate -- -n CreateIndustryInsights and ship the above DDL.

Create Entity IndustryInsight with a composite @Unique(["sector","metric","effective_from"]).

Repository helpers

async upsertInsights(rows: InsightDTO[]) { /* bulk INSERT ... ON CONFLICT */ }
async get(sector: string, metric: string, date = new Date()): Promise<IndustryInsight> { ... }

ETL job syncIndustryInsights.ts (invoked by nodeâ€‘cron weekly):

Download latest IRIS JSON (converted once from PDF).

Parse to InsightDTO[].

Call upsertInsights().

Dashboard adapter

const lmP90 = await benchmarkService.get('GLOBAL', 'LM_P90');
const ours  = simulation.p90Loss;
const ratio = ours / lmP90.value_numeric;

Display ratio as gauge or colourâ€‘coded badge.

Unit tests

Verify upsertInsights() preserves historical rows and updates effective_to of superseded versions.

Validate percentile helper logic.