1) Switch to a monotone interpolator
Change your <Line type="natural" … /> to:

diff
Copy
- <Line
-   type="natural"
+ <Line
+   type="monotone"
    dataKey="probability"
    name="Current Loss Probability"
    stroke="#3b82f6"
    strokeWidth={3}
    …
/>
type="monotone" guarantees no overshoot—your curve will follow the true maximum and minimum of your data without spurious peaks.

2) Smooth the underlying data with true linear interpolation
Rather than recomputing probability on the fly via counts, build an explicit exposure-probability curve array for every filter type, then feed that into your chart’s generic interpolation logic:

ts
Copy
// inside your chartData useMemo, replace the filtered‐views branch…
let actualExposureCurveData: { impact:number, probability:number }[] = [];
if (filterType === 'all') {
  actualExposureCurveData = currentExposure?.exposureCurveData || [];
} else {
  // build a true curve array once:
  const exposures = filteredRisks
    .map(r => ensureFiniteNumber(r.residualRisk||r.inherentRisk||0))
    .filter(v => v > 0)
    .sort((a,b)=>b-a);
  const n = exposures.length;
  actualExposureCurveData = exposures.map((impact, i) => ({
    impact,
    probability: (i+1)/n
  }));
}

// then, for *all* cases, interpolate:
const sortedCurve = actualExposureCurveData.sort((a,b)=>b.impact-a.impact);
for (let i=0; i<=numPoints; i++){
  const lossExposure = i * (maxExposure*1.2/numPoints);
  let probability: number;
  
  // linear interpolation between the two surrounding points:
  if (lossExposure >= sortedCurve[0].impact) {
    probability = sortedCurve[0].probability*100;
  } else if (lossExposure <= sortedCurve[n-1].impact) {
    probability = sortedCurve[n-1].probability*100;
  } else {
    let lo=sortedCurve[n-1], hi=sortedCurve[0];
    for (let j=0; j<n-1; j++){
      if (lossExposure <= sortedCurve[j].impact && lossExposure >= sortedCurve[j+1].impact){
        hi = sortedCurve[j];
        lo = sortedCurve[j+1];
        break;
      }
    }
    const ratio = (lossExposure - lo.impact) / (hi.impact - lo.impact);
    probability = (lo.probability + ratio*(hi.probability - lo.probability))*100;
  }

  // …then compute toleranceProbability, unacceptableRisk, etc. exactly as you already do.
}
By

standardizing on a single curve array, and

using monotone splines,

you’ll remove the artificial “spikes” and get a smooth, strictly monotonic exceedance curve.







